{"version":3,"file":"432.js","mappings":"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","sources":["webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/tslib.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/utils/uuid.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/errors.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/core/error.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/utils/values.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/utils/log.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/version.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/detect-platform.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/shims.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/request-options.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/utils/bytes.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/core/api-promise.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/core/pagination.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/core/streaming.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/parse.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/uploads.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/to-file.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/core/resource.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/headers.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/utils/path.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/resources/beta/files.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/resources/beta/models.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/constants.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/resources/completions.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/resources/models.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/utils/env.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/client.mjs","webpack://excel-custom-functions/./node_modules/@anthropic-ai/sdk/internal/utils/sleep.mjs"],"sourcesContent":["function __classPrivateFieldSet(receiver, state, value, kind, f) {\n    if (kind === \"m\")\n        throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f)\n        throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver))\n        throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? (f.value = value) : state.set(receiver, value), value;\n}\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f)\n        throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver))\n        throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nexport { __classPrivateFieldSet, __classPrivateFieldGet };\n","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n/**\n * https://stackoverflow.com/a/2117523\n */\nexport let uuid4 = function () {\n    const { crypto } = globalThis;\n    if (crypto?.randomUUID) {\n        uuid4 = crypto.randomUUID.bind(crypto);\n        return crypto.randomUUID();\n    }\n    const u8 = new Uint8Array(1);\n    const randomByte = crypto ? () => crypto.getRandomValues(u8)[0] : () => (Math.random() * 0xff) & 0xff;\n    return '10000000-1000-4000-8000-100000000000'.replace(/[018]/g, (c) => (+c ^ (randomByte() & (15 >> (+c / 4)))).toString(16));\n};\n//# sourceMappingURL=uuid.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nexport function isAbortError(err) {\n    return (typeof err === 'object' &&\n        err !== null &&\n        // Spec-compliant fetch implementations\n        (('name' in err && err.name === 'AbortError') ||\n            // Expo fetch\n            ('message' in err && String(err.message).includes('FetchRequestCanceledException'))));\n}\nexport const castToError = (err) => {\n    if (err instanceof Error)\n        return err;\n    if (typeof err === 'object' && err !== null) {\n        try {\n            if (Object.prototype.toString.call(err) === '[object Error]') {\n                // @ts-ignore - not all envs have native support for cause yet\n                const error = new Error(err.message, err.cause ? { cause: err.cause } : {});\n                if (err.stack)\n                    error.stack = err.stack;\n                // @ts-ignore - not all envs have native support for cause yet\n                if (err.cause && !error.cause)\n                    error.cause = err.cause;\n                if (err.name)\n                    error.name = err.name;\n                return error;\n            }\n        }\n        catch { }\n        try {\n            return new Error(JSON.stringify(err));\n        }\n        catch { }\n    }\n    return new Error(err);\n};\n//# sourceMappingURL=errors.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { castToError } from \"../internal/errors.mjs\";\nexport class AnthropicError extends Error {\n}\nexport class APIError extends AnthropicError {\n    constructor(status, error, message, headers) {\n        super(`${APIError.makeMessage(status, error, message)}`);\n        this.status = status;\n        this.headers = headers;\n        this.requestID = headers?.get('request-id');\n        this.error = error;\n    }\n    static makeMessage(status, error, message) {\n        const msg = error?.message ?\n            typeof error.message === 'string' ?\n                error.message\n                : JSON.stringify(error.message)\n            : error ? JSON.stringify(error)\n                : message;\n        if (status && msg) {\n            return `${status} ${msg}`;\n        }\n        if (status) {\n            return `${status} status code (no body)`;\n        }\n        if (msg) {\n            return msg;\n        }\n        return '(no status code or body)';\n    }\n    static generate(status, errorResponse, message, headers) {\n        if (!status || !headers) {\n            return new APIConnectionError({ message, cause: castToError(errorResponse) });\n        }\n        const error = errorResponse;\n        if (status === 400) {\n            return new BadRequestError(status, error, message, headers);\n        }\n        if (status === 401) {\n            return new AuthenticationError(status, error, message, headers);\n        }\n        if (status === 403) {\n            return new PermissionDeniedError(status, error, message, headers);\n        }\n        if (status === 404) {\n            return new NotFoundError(status, error, message, headers);\n        }\n        if (status === 409) {\n            return new ConflictError(status, error, message, headers);\n        }\n        if (status === 422) {\n            return new UnprocessableEntityError(status, error, message, headers);\n        }\n        if (status === 429) {\n            return new RateLimitError(status, error, message, headers);\n        }\n        if (status >= 500) {\n            return new InternalServerError(status, error, message, headers);\n        }\n        return new APIError(status, error, message, headers);\n    }\n}\nexport class APIUserAbortError extends APIError {\n    constructor({ message } = {}) {\n        super(undefined, undefined, message || 'Request was aborted.', undefined);\n    }\n}\nexport class APIConnectionError extends APIError {\n    constructor({ message, cause }) {\n        super(undefined, undefined, message || 'Connection error.', undefined);\n        // in some environments the 'cause' property is already declared\n        // @ts-ignore\n        if (cause)\n            this.cause = cause;\n    }\n}\nexport class APIConnectionTimeoutError extends APIConnectionError {\n    constructor({ message } = {}) {\n        super({ message: message ?? 'Request timed out.' });\n    }\n}\nexport class BadRequestError extends APIError {\n}\nexport class AuthenticationError extends APIError {\n}\nexport class PermissionDeniedError extends APIError {\n}\nexport class NotFoundError extends APIError {\n}\nexport class ConflictError extends APIError {\n}\nexport class UnprocessableEntityError extends APIError {\n}\nexport class RateLimitError extends APIError {\n}\nexport class InternalServerError extends APIError {\n}\n//# sourceMappingURL=error.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { AnthropicError } from \"../../core/error.mjs\";\n// https://url.spec.whatwg.org/#url-scheme-string\nconst startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;\nexport const isAbsoluteURL = (url) => {\n    return startsWithSchemeRegexp.test(url);\n};\n/** Returns an object if the given value isn't an object, otherwise returns as-is */\nexport function maybeObj(x) {\n    if (typeof x !== 'object') {\n        return {};\n    }\n    return x ?? {};\n}\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj) {\n    if (!obj)\n        return true;\n    for (const _k in obj)\n        return false;\n    return true;\n}\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nexport function isObj(obj) {\n    return obj != null && typeof obj === 'object' && !Array.isArray(obj);\n}\nexport const ensurePresent = (value) => {\n    if (value == null) {\n        throw new AnthropicError(`Expected a value to be given but received ${value} instead.`);\n    }\n    return value;\n};\nexport const validatePositiveInteger = (name, n) => {\n    if (typeof n !== 'number' || !Number.isInteger(n)) {\n        throw new AnthropicError(`${name} must be an integer`);\n    }\n    if (n < 0) {\n        throw new AnthropicError(`${name} must be a positive integer`);\n    }\n    return n;\n};\nexport const coerceInteger = (value) => {\n    if (typeof value === 'number')\n        return Math.round(value);\n    if (typeof value === 'string')\n        return parseInt(value, 10);\n    throw new AnthropicError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexport const coerceFloat = (value) => {\n    if (typeof value === 'number')\n        return value;\n    if (typeof value === 'string')\n        return parseFloat(value);\n    throw new AnthropicError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexport const coerceBoolean = (value) => {\n    if (typeof value === 'boolean')\n        return value;\n    if (typeof value === 'string')\n        return value === 'true';\n    return Boolean(value);\n};\nexport const maybeCoerceInteger = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceInteger(value);\n};\nexport const maybeCoerceFloat = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceFloat(value);\n};\nexport const maybeCoerceBoolean = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceBoolean(value);\n};\nexport const safeJSON = (text) => {\n    try {\n        return JSON.parse(text);\n    }\n    catch (err) {\n        return undefined;\n    }\n};\n//# sourceMappingURL=values.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { hasOwn } from \"./values.mjs\";\nconst levelNumbers = {\n    off: 0,\n    error: 200,\n    warn: 300,\n    info: 400,\n    debug: 500,\n};\nexport const parseLogLevel = (maybeLevel, sourceName, client) => {\n    if (!maybeLevel) {\n        return undefined;\n    }\n    if (hasOwn(levelNumbers, maybeLevel)) {\n        return maybeLevel;\n    }\n    loggerFor(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);\n    return undefined;\n};\nfunction noop() { }\nfunction makeLogFn(fnLevel, logger, logLevel) {\n    if (!logger || levelNumbers[fnLevel] > levelNumbers[logLevel]) {\n        return noop;\n    }\n    else {\n        // Don't wrap logger functions, we want the stacktrace intact!\n        return logger[fnLevel].bind(logger);\n    }\n}\nconst noopLogger = {\n    error: noop,\n    warn: noop,\n    info: noop,\n    debug: noop,\n};\nlet cachedLoggers = new WeakMap();\nexport function loggerFor(client) {\n    const logger = client.logger;\n    const logLevel = client.logLevel ?? 'off';\n    if (!logger) {\n        return noopLogger;\n    }\n    const cachedLogger = cachedLoggers.get(logger);\n    if (cachedLogger && cachedLogger[0] === logLevel) {\n        return cachedLogger[1];\n    }\n    const levelLogger = {\n        error: makeLogFn('error', logger, logLevel),\n        warn: makeLogFn('warn', logger, logLevel),\n        info: makeLogFn('info', logger, logLevel),\n        debug: makeLogFn('debug', logger, logLevel),\n    };\n    cachedLoggers.set(logger, [logLevel, levelLogger]);\n    return levelLogger;\n}\nexport const formatRequestDetails = (details) => {\n    if (details.options) {\n        details.options = { ...details.options };\n        delete details.options['headers']; // redundant + leaks internals\n    }\n    if (details.headers) {\n        details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [\n            name,\n            (name.toLowerCase() === 'x-api-key' ||\n                name.toLowerCase() === 'authorization' ||\n                name.toLowerCase() === 'cookie' ||\n                name.toLowerCase() === 'set-cookie') ?\n                '***'\n                : value,\n        ]));\n    }\n    if ('retryOfRequestLogID' in details) {\n        if (details.retryOfRequestLogID) {\n            details.retryOf = details.retryOfRequestLogID;\n        }\n        delete details.retryOfRequestLogID;\n    }\n    return details;\n};\n//# sourceMappingURL=log.mjs.map","export const VERSION = '0.53.0'; // x-release-please-version\n//# sourceMappingURL=version.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { VERSION } from \"../version.mjs\";\nexport const isRunningInBrowser = () => {\n    return (\n    // @ts-ignore\n    typeof window !== 'undefined' &&\n        // @ts-ignore\n        typeof window.document !== 'undefined' &&\n        // @ts-ignore\n        typeof navigator !== 'undefined');\n};\n/**\n * Note this does not detect 'browser'; for that, use getBrowserInfo().\n */\nfunction getDetectedPlatform() {\n    if (typeof Deno !== 'undefined' && Deno.build != null) {\n        return 'deno';\n    }\n    if (typeof EdgeRuntime !== 'undefined') {\n        return 'edge';\n    }\n    if (Object.prototype.toString.call(typeof globalThis.process !== 'undefined' ? globalThis.process : 0) === '[object process]') {\n        return 'node';\n    }\n    return 'unknown';\n}\nconst getPlatformProperties = () => {\n    const detectedPlatform = getDetectedPlatform();\n    if (detectedPlatform === 'deno') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': normalizePlatform(Deno.build.os),\n            'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n            'X-Stainless-Runtime': 'deno',\n            'X-Stainless-Runtime-Version': typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown',\n        };\n    }\n    if (typeof EdgeRuntime !== 'undefined') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': `other:${EdgeRuntime}`,\n            'X-Stainless-Runtime': 'edge',\n            'X-Stainless-Runtime-Version': globalThis.process.version,\n        };\n    }\n    // Check if Node.js\n    if (detectedPlatform === 'node') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': normalizePlatform(globalThis.process.platform ?? 'unknown'),\n            'X-Stainless-Arch': normalizeArch(globalThis.process.arch ?? 'unknown'),\n            'X-Stainless-Runtime': 'node',\n            'X-Stainless-Runtime-Version': globalThis.process.version ?? 'unknown',\n        };\n    }\n    const browserInfo = getBrowserInfo();\n    if (browserInfo) {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': 'unknown',\n            'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n            'X-Stainless-Runtime-Version': browserInfo.version,\n        };\n    }\n    // TODO add support for Cloudflare workers, etc.\n    return {\n        'X-Stainless-Lang': 'js',\n        'X-Stainless-Package-Version': VERSION,\n        'X-Stainless-OS': 'Unknown',\n        'X-Stainless-Arch': 'unknown',\n        'X-Stainless-Runtime': 'unknown',\n        'X-Stainless-Runtime-Version': 'unknown',\n    };\n};\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction getBrowserInfo() {\n    if (typeof navigator === 'undefined' || !navigator) {\n        return null;\n    }\n    // NOTE: The order matters here!\n    const browserPatterns = [\n        { key: 'edge', pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'chrome', pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'firefox', pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'safari', pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\n    ];\n    // Find the FIRST matching browser\n    for (const { key, pattern } of browserPatterns) {\n        const match = pattern.exec(navigator.userAgent);\n        if (match) {\n            const major = match[1] || 0;\n            const minor = match[2] || 0;\n            const patch = match[3] || 0;\n            return { browser: key, version: `${major}.${minor}.${patch}` };\n        }\n    }\n    return null;\n}\nconst normalizeArch = (arch) => {\n    // Node docs:\n    // - https://nodejs.org/api/process.html#processarch\n    // Deno docs:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    if (arch === 'x32')\n        return 'x32';\n    if (arch === 'x86_64' || arch === 'x64')\n        return 'x64';\n    if (arch === 'arm')\n        return 'arm';\n    if (arch === 'aarch64' || arch === 'arm64')\n        return 'arm64';\n    if (arch)\n        return `other:${arch}`;\n    return 'unknown';\n};\nconst normalizePlatform = (platform) => {\n    // Node platforms:\n    // - https://nodejs.org/api/process.html#processplatform\n    // Deno platforms:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    // - https://github.com/denoland/deno/issues/14799\n    platform = platform.toLowerCase();\n    // NOTE: this iOS check is untested and may not work\n    // Node does not work natively on IOS, there is a fork at\n    // https://github.com/nodejs-mobile/nodejs-mobile\n    // however it is unknown at the time of writing how to detect if it is running\n    if (platform.includes('ios'))\n        return 'iOS';\n    if (platform === 'android')\n        return 'Android';\n    if (platform === 'darwin')\n        return 'MacOS';\n    if (platform === 'win32')\n        return 'Windows';\n    if (platform === 'freebsd')\n        return 'FreeBSD';\n    if (platform === 'openbsd')\n        return 'OpenBSD';\n    if (platform === 'linux')\n        return 'Linux';\n    if (platform)\n        return `Other:${platform}`;\n    return 'Unknown';\n};\nlet _platformHeaders;\nexport const getPlatformHeaders = () => {\n    return (_platformHeaders ?? (_platformHeaders = getPlatformProperties()));\n};\n//# sourceMappingURL=detect-platform.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nexport function getDefaultFetch() {\n    if (typeof fetch !== 'undefined') {\n        return fetch;\n    }\n    throw new Error('`fetch` is not defined as a global; Either pass `fetch` to the client, `new Anthropic({ fetch })` or polyfill the global, `globalThis.fetch = fetch`');\n}\nexport function makeReadableStream(...args) {\n    const ReadableStream = globalThis.ReadableStream;\n    if (typeof ReadableStream === 'undefined') {\n        // Note: All of the platforms / runtimes we officially support already define\n        // `ReadableStream` as a global, so this should only ever be hit on unsupported runtimes.\n        throw new Error('`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`');\n    }\n    return new ReadableStream(...args);\n}\nexport function ReadableStreamFrom(iterable) {\n    let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n    return makeReadableStream({\n        start() { },\n        async pull(controller) {\n            const { done, value } = await iter.next();\n            if (done) {\n                controller.close();\n            }\n            else {\n                controller.enqueue(value);\n            }\n        },\n        async cancel() {\n            await iter.return?.();\n        },\n    });\n}\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function ReadableStreamToAsyncIterable(stream) {\n    if (stream[Symbol.asyncIterator])\n        return stream;\n    const reader = stream.getReader();\n    return {\n        async next() {\n            try {\n                const result = await reader.read();\n                if (result?.done)\n                    reader.releaseLock(); // release lock when stream becomes closed\n                return result;\n            }\n            catch (e) {\n                reader.releaseLock(); // release lock when stream becomes errored\n                throw e;\n            }\n        },\n        async return() {\n            const cancelPromise = reader.cancel();\n            reader.releaseLock();\n            await cancelPromise;\n            return { done: true, value: undefined };\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\n/**\n * Cancels a ReadableStream we don't need to consume.\n * See https://undici.nodejs.org/#/?id=garbage-collection\n */\nexport async function CancelReadableStream(stream) {\n    if (stream === null || typeof stream !== 'object')\n        return;\n    if (stream[Symbol.asyncIterator]) {\n        await stream[Symbol.asyncIterator]().return?.();\n        return;\n    }\n    const reader = stream.getReader();\n    const cancelPromise = reader.cancel();\n    reader.releaseLock();\n    await cancelPromise;\n}\n//# sourceMappingURL=shims.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nexport const FallbackEncoder = ({ headers, body }) => {\n    return {\n        bodyHeaders: {\n            'content-type': 'application/json',\n        },\n        body: JSON.stringify(body),\n    };\n};\n//# sourceMappingURL=request-options.mjs.map","export function concatBytes(buffers) {\n    let length = 0;\n    for (const buffer of buffers) {\n        length += buffer.length;\n    }\n    const output = new Uint8Array(length);\n    let index = 0;\n    for (const buffer of buffers) {\n        output.set(buffer, index);\n        index += buffer.length;\n    }\n    return output;\n}\nlet encodeUTF8_;\nexport function encodeUTF8(str) {\n    let encoder;\n    return (encodeUTF8_ ??\n        ((encoder = new globalThis.TextEncoder()), (encodeUTF8_ = encoder.encode.bind(encoder))))(str);\n}\nlet decodeUTF8_;\nexport function decodeUTF8(bytes) {\n    let decoder;\n    return (decodeUTF8_ ??\n        ((decoder = new globalThis.TextDecoder()), (decodeUTF8_ = decoder.decode.bind(decoder))))(bytes);\n}\n//# sourceMappingURL=bytes.mjs.map","var _LineDecoder_buffer, _LineDecoder_carriageReturnIndex;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"../tslib.mjs\";\nimport { concatBytes, decodeUTF8, encodeUTF8 } from \"../utils/bytes.mjs\";\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nexport class LineDecoder {\n    constructor() {\n        _LineDecoder_buffer.set(this, void 0);\n        _LineDecoder_carriageReturnIndex.set(this, void 0);\n        __classPrivateFieldSet(this, _LineDecoder_buffer, new Uint8Array(), \"f\");\n        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n    }\n    decode(chunk) {\n        if (chunk == null) {\n            return [];\n        }\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n            : typeof chunk === 'string' ? encodeUTF8(chunk)\n                : chunk;\n        __classPrivateFieldSet(this, _LineDecoder_buffer, concatBytes([__classPrivateFieldGet(this, _LineDecoder_buffer, \"f\"), binaryChunk]), \"f\");\n        const lines = [];\n        let patternIndex;\n        while ((patternIndex = findNewlineIndex(__classPrivateFieldGet(this, _LineDecoder_buffer, \"f\"), __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\"))) != null) {\n            if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") == null) {\n                // skip until we either get a corresponding `\\n`, a new `\\r` or nothing\n                __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, \"f\");\n                continue;\n            }\n            // we got double \\r or \\rtext\\n\n            if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") != null &&\n                (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") + 1 || patternIndex.carriage)) {\n                lines.push(decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, \"f\").subarray(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") - 1)));\n                __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, \"f\").subarray(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\")), \"f\");\n                __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n                continue;\n            }\n            const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;\n            const line = decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, \"f\").subarray(0, endIndex));\n            lines.push(line);\n            __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, \"f\").subarray(patternIndex.index), \"f\");\n            __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n        }\n        return lines;\n    }\n    flush() {\n        if (!__classPrivateFieldGet(this, _LineDecoder_buffer, \"f\").length) {\n            return [];\n        }\n        return this.decode('\\n');\n    }\n}\n_LineDecoder_buffer = new WeakMap(), _LineDecoder_carriageReturnIndex = new WeakMap();\n// prettier-ignore\nLineDecoder.NEWLINE_CHARS = new Set(['\\n', '\\r']);\nLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\n/**\n * This function searches the buffer for the end patterns, (\\r or \\n)\n * and returns an object with the index preceding the matched newline and the\n * index after the newline char. `null` is returned if no new line is found.\n *\n * ```ts\n * findNewLineIndex('abc\\ndef') -> { preceding: 2, index: 3 }\n * ```\n */\nfunction findNewlineIndex(buffer, startIndex) {\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for (let i = startIndex ?? 0; i < buffer.length; i++) {\n        if (buffer[i] === newline) {\n            return { preceding: i, index: i + 1, carriage: false };\n        }\n        if (buffer[i] === carriage) {\n            return { preceding: i, index: i + 1, carriage: true };\n        }\n    }\n    return null;\n}\nexport function findDoubleNewlineIndex(buffer) {\n    // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n    // and returns the index right after the first occurrence of any pattern,\n    // or -1 if none of the patterns are found.\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for (let i = 0; i < buffer.length - 1; i++) {\n        if (buffer[i] === newline && buffer[i + 1] === newline) {\n            // \\n\\n\n            return i + 2;\n        }\n        if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n            // \\r\\r\n            return i + 2;\n        }\n        if (buffer[i] === carriage &&\n            buffer[i + 1] === newline &&\n            i + 3 < buffer.length &&\n            buffer[i + 2] === carriage &&\n            buffer[i + 3] === newline) {\n            // \\r\\n\\r\\n\n            return i + 4;\n        }\n    }\n    return -1;\n}\n//# sourceMappingURL=line.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar _APIPromise_client;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"../internal/tslib.mjs\";\nimport { defaultParseResponse, addRequestID, } from \"../internal/parse.mjs\";\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class APIPromise extends Promise {\n    constructor(client, responsePromise, parseResponse = defaultParseResponse) {\n        super((resolve) => {\n            // this is maybe a bit weird but this has to be a no-op to not implicitly\n            // parse the response body; instead .then, .catch, .finally are overridden\n            // to parse the response\n            resolve(null);\n        });\n        this.responsePromise = responsePromise;\n        this.parseResponse = parseResponse;\n        _APIPromise_client.set(this, void 0);\n        __classPrivateFieldSet(this, _APIPromise_client, client, \"f\");\n    }\n    _thenUnwrap(transform) {\n        return new APIPromise(__classPrivateFieldGet(this, _APIPromise_client, \"f\"), this.responsePromise, async (client, props) => addRequestID(transform(await this.parseResponse(client, props), props), props.response));\n    }\n    /**\n     * Gets the raw `Response` instance instead of parsing the response\n     * data.\n     *\n     * If you want to parse the response body but still get the `Response`\n     * instance, you can use {@link withResponse()}.\n     *\n     *  Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` or add `\"lib\": [\"DOM\"]`\n     * to your `tsconfig.json`.\n     */\n    asResponse() {\n        return this.responsePromise.then((p) => p.response);\n    }\n    /**\n     * Gets the parsed response data, the raw `Response` instance and the ID of the request,\n     * returned via the `request-id` header which is useful for debugging requests and resporting\n     * issues to Anthropic.\n     *\n     * If you just want to get the raw `Response` instance without parsing it,\n     * you can use {@link asResponse()}.\n     *\n     *  Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` or add `\"lib\": [\"DOM\"]`\n     * to your `tsconfig.json`.\n     */\n    async withResponse() {\n        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n        return { data, response, request_id: response.headers.get('request-id') };\n    }\n    parse() {\n        if (!this.parsedPromise) {\n            this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(__classPrivateFieldGet(this, _APIPromise_client, \"f\"), data));\n        }\n        return this.parsedPromise;\n    }\n    then(onfulfilled, onrejected) {\n        return this.parse().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.parse().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.parse().finally(onfinally);\n    }\n}\n_APIPromise_client = new WeakMap();\n//# sourceMappingURL=api-promise.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar _AbstractPage_client;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"../internal/tslib.mjs\";\nimport { AnthropicError } from \"./error.mjs\";\nimport { defaultParseResponse } from \"../internal/parse.mjs\";\nimport { APIPromise } from \"./api-promise.mjs\";\nimport { maybeObj } from \"../internal/utils/values.mjs\";\nexport class AbstractPage {\n    constructor(client, response, body, options) {\n        _AbstractPage_client.set(this, void 0);\n        __classPrivateFieldSet(this, _AbstractPage_client, client, \"f\");\n        this.options = options;\n        this.response = response;\n        this.body = body;\n    }\n    hasNextPage() {\n        const items = this.getPaginatedItems();\n        if (!items.length)\n            return false;\n        return this.nextPageRequestOptions() != null;\n    }\n    async getNextPage() {\n        const nextOptions = this.nextPageRequestOptions();\n        if (!nextOptions) {\n            throw new AnthropicError('No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.');\n        }\n        return await __classPrivateFieldGet(this, _AbstractPage_client, \"f\").requestAPIList(this.constructor, nextOptions);\n    }\n    async *iterPages() {\n        let page = this;\n        yield page;\n        while (page.hasNextPage()) {\n            page = await page.getNextPage();\n            yield page;\n        }\n    }\n    async *[(_AbstractPage_client = new WeakMap(), Symbol.asyncIterator)]() {\n        for await (const page of this.iterPages()) {\n            for (const item of page.getPaginatedItems()) {\n                yield item;\n            }\n        }\n    }\n}\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\nexport class PagePromise extends APIPromise {\n    constructor(client, request, Page) {\n        super(client, request, async (client, props) => new Page(client, props.response, await defaultParseResponse(client, props), props.options));\n    }\n    /**\n     * Allow auto-paginating iteration on an unawaited list call, eg:\n     *\n     *    for await (const item of client.items.list()) {\n     *      console.log(item)\n     *    }\n     */\n    async *[Symbol.asyncIterator]() {\n        const page = await this;\n        for await (const item of page) {\n            yield item;\n        }\n    }\n}\nexport class Page extends AbstractPage {\n    constructor(client, response, body, options) {\n        super(client, response, body, options);\n        this.data = body.data || [];\n        this.has_more = body.has_more || false;\n        this.first_id = body.first_id || null;\n        this.last_id = body.last_id || null;\n    }\n    getPaginatedItems() {\n        return this.data ?? [];\n    }\n    hasNextPage() {\n        if (this.has_more === false) {\n            return false;\n        }\n        return super.hasNextPage();\n    }\n    nextPageRequestOptions() {\n        if (this.options.query?.['before_id']) {\n            // in reverse\n            const first_id = this.first_id;\n            if (!first_id) {\n                return null;\n            }\n            return {\n                ...this.options,\n                query: {\n                    ...maybeObj(this.options.query),\n                    before_id: first_id,\n                },\n            };\n        }\n        const cursor = this.last_id;\n        if (!cursor) {\n            return null;\n        }\n        return {\n            ...this.options,\n            query: {\n                ...maybeObj(this.options.query),\n                after_id: cursor,\n            },\n        };\n    }\n}\n//# sourceMappingURL=pagination.mjs.map","import { AnthropicError } from \"./error.mjs\";\nimport { makeReadableStream } from \"../internal/shims.mjs\";\nimport { findDoubleNewlineIndex, LineDecoder } from \"../internal/decoders/line.mjs\";\nimport { ReadableStreamToAsyncIterable } from \"../internal/shims.mjs\";\nimport { isAbortError } from \"../internal/errors.mjs\";\nimport { safeJSON } from \"../internal/utils/values.mjs\";\nimport { encodeUTF8 } from \"../internal/utils/bytes.mjs\";\nimport { APIError } from \"./error.mjs\";\nexport class Stream {\n    constructor(iterator, controller) {\n        this.iterator = iterator;\n        this.controller = controller;\n    }\n    static fromSSEResponse(response, controller) {\n        let consumed = false;\n        async function* iterator() {\n            if (consumed) {\n                throw new AnthropicError('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n            }\n            consumed = true;\n            let done = false;\n            try {\n                for await (const sse of _iterSSEMessages(response, controller)) {\n                    if (sse.event === 'completion') {\n                        try {\n                            yield JSON.parse(sse.data);\n                        }\n                        catch (e) {\n                            console.error(`Could not parse message into JSON:`, sse.data);\n                            console.error(`From chunk:`, sse.raw);\n                            throw e;\n                        }\n                    }\n                    if (sse.event === 'message_start' ||\n                        sse.event === 'message_delta' ||\n                        sse.event === 'message_stop' ||\n                        sse.event === 'content_block_start' ||\n                        sse.event === 'content_block_delta' ||\n                        sse.event === 'content_block_stop') {\n                        try {\n                            yield JSON.parse(sse.data);\n                        }\n                        catch (e) {\n                            console.error(`Could not parse message into JSON:`, sse.data);\n                            console.error(`From chunk:`, sse.raw);\n                            throw e;\n                        }\n                    }\n                    if (sse.event === 'ping') {\n                        continue;\n                    }\n                    if (sse.event === 'error') {\n                        throw new APIError(undefined, safeJSON(sse.data) ?? sse.data, undefined, response.headers);\n                    }\n                }\n                done = true;\n            }\n            catch (e) {\n                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                if (isAbortError(e))\n                    return;\n                throw e;\n            }\n            finally {\n                // If the user `break`s, abort the ongoing request.\n                if (!done)\n                    controller.abort();\n            }\n        }\n        return new Stream(iterator, controller);\n    }\n    /**\n     * Generates a Stream from a newline-separated ReadableStream\n     * where each item is a JSON value.\n     */\n    static fromReadableStream(readableStream, controller) {\n        let consumed = false;\n        async function* iterLines() {\n            const lineDecoder = new LineDecoder();\n            const iter = ReadableStreamToAsyncIterable(readableStream);\n            for await (const chunk of iter) {\n                for (const line of lineDecoder.decode(chunk)) {\n                    yield line;\n                }\n            }\n            for (const line of lineDecoder.flush()) {\n                yield line;\n            }\n        }\n        async function* iterator() {\n            if (consumed) {\n                throw new AnthropicError('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n            }\n            consumed = true;\n            let done = false;\n            try {\n                for await (const line of iterLines()) {\n                    if (done)\n                        continue;\n                    if (line)\n                        yield JSON.parse(line);\n                }\n                done = true;\n            }\n            catch (e) {\n                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                if (isAbortError(e))\n                    return;\n                throw e;\n            }\n            finally {\n                // If the user `break`s, abort the ongoing request.\n                if (!done)\n                    controller.abort();\n            }\n        }\n        return new Stream(iterator, controller);\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterator();\n    }\n    /**\n     * Splits the stream into two streams which can be\n     * independently read from at different speeds.\n     */\n    tee() {\n        const left = [];\n        const right = [];\n        const iterator = this.iterator();\n        const teeIterator = (queue) => {\n            return {\n                next: () => {\n                    if (queue.length === 0) {\n                        const result = iterator.next();\n                        left.push(result);\n                        right.push(result);\n                    }\n                    return queue.shift();\n                },\n            };\n        };\n        return [\n            new Stream(() => teeIterator(left), this.controller),\n            new Stream(() => teeIterator(right), this.controller),\n        ];\n    }\n    /**\n     * Converts this stream to a newline-separated ReadableStream of\n     * JSON stringified values in the stream\n     * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n     */\n    toReadableStream() {\n        const self = this;\n        let iter;\n        return makeReadableStream({\n            async start() {\n                iter = self[Symbol.asyncIterator]();\n            },\n            async pull(ctrl) {\n                try {\n                    const { value, done } = await iter.next();\n                    if (done)\n                        return ctrl.close();\n                    const bytes = encodeUTF8(JSON.stringify(value) + '\\n');\n                    ctrl.enqueue(bytes);\n                }\n                catch (err) {\n                    ctrl.error(err);\n                }\n            },\n            async cancel() {\n                await iter.return?.();\n            },\n        });\n    }\n}\nexport async function* _iterSSEMessages(response, controller) {\n    if (!response.body) {\n        controller.abort();\n        if (typeof globalThis.navigator !== 'undefined' &&\n            globalThis.navigator.product === 'ReactNative') {\n            throw new AnthropicError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);\n        }\n        throw new AnthropicError(`Attempted to iterate over a response with no body`);\n    }\n    const sseDecoder = new SSEDecoder();\n    const lineDecoder = new LineDecoder();\n    const iter = ReadableStreamToAsyncIterable(response.body);\n    for await (const sseChunk of iterSSEChunks(iter)) {\n        for (const line of lineDecoder.decode(sseChunk)) {\n            const sse = sseDecoder.decode(line);\n            if (sse)\n                yield sse;\n        }\n    }\n    for (const line of lineDecoder.flush()) {\n        const sse = sseDecoder.decode(line);\n        if (sse)\n            yield sse;\n    }\n}\n/**\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n */\nasync function* iterSSEChunks(iterator) {\n    let data = new Uint8Array();\n    for await (const chunk of iterator) {\n        if (chunk == null) {\n            continue;\n        }\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n            : typeof chunk === 'string' ? encodeUTF8(chunk)\n                : chunk;\n        let newData = new Uint8Array(data.length + binaryChunk.length);\n        newData.set(data);\n        newData.set(binaryChunk, data.length);\n        data = newData;\n        let patternIndex;\n        while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\n            yield data.slice(0, patternIndex);\n            data = data.slice(patternIndex);\n        }\n    }\n    if (data.length > 0) {\n        yield data;\n    }\n}\nclass SSEDecoder {\n    constructor() {\n        this.event = null;\n        this.data = [];\n        this.chunks = [];\n    }\n    decode(line) {\n        if (line.endsWith('\\r')) {\n            line = line.substring(0, line.length - 1);\n        }\n        if (!line) {\n            // empty line and we didn't previously encounter any messages\n            if (!this.event && !this.data.length)\n                return null;\n            const sse = {\n                event: this.event,\n                data: this.data.join('\\n'),\n                raw: this.chunks,\n            };\n            this.event = null;\n            this.data = [];\n            this.chunks = [];\n            return sse;\n        }\n        this.chunks.push(line);\n        if (line.startsWith(':')) {\n            return null;\n        }\n        let [fieldname, _, value] = partition(line, ':');\n        if (value.startsWith(' ')) {\n            value = value.substring(1);\n        }\n        if (fieldname === 'event') {\n            this.event = value;\n        }\n        else if (fieldname === 'data') {\n            this.data.push(value);\n        }\n        return null;\n    }\n}\nfunction partition(str, delimiter) {\n    const index = str.indexOf(delimiter);\n    if (index !== -1) {\n        return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n    }\n    return [str, '', ''];\n}\n//# sourceMappingURL=streaming.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { Stream } from \"../core/streaming.mjs\";\nimport { formatRequestDetails, loggerFor } from \"./utils/log.mjs\";\nexport async function defaultParseResponse(client, props) {\n    const { response, requestLogID, retryOfRequestLogID, startTime } = props;\n    const body = await (async () => {\n        if (props.options.stream) {\n            loggerFor(client).debug('response', response.status, response.url, response.headers, response.body);\n            // Note: there is an invariant here that isn't represented in the type system\n            // that if you set `stream: true` the response type must also be `Stream<T>`\n            if (props.options.__streamClass) {\n                return props.options.__streamClass.fromSSEResponse(response, props.controller);\n            }\n            return Stream.fromSSEResponse(response, props.controller);\n        }\n        // fetch refuses to read the body when the status code is 204.\n        if (response.status === 204) {\n            return null;\n        }\n        if (props.options.__binaryResponse) {\n            return response;\n        }\n        const contentType = response.headers.get('content-type');\n        const mediaType = contentType?.split(';')[0]?.trim();\n        const isJSON = mediaType?.includes('application/json') || mediaType?.endsWith('+json');\n        if (isJSON) {\n            const json = await response.json();\n            return addRequestID(json, response);\n        }\n        const text = await response.text();\n        return text;\n    })();\n    loggerFor(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails({\n        retryOfRequestLogID,\n        url: response.url,\n        status: response.status,\n        body,\n        durationMs: Date.now() - startTime,\n    }));\n    return body;\n}\nexport function addRequestID(value, response) {\n    if (!value || typeof value !== 'object' || Array.isArray(value)) {\n        return value;\n    }\n    return Object.defineProperty(value, '_request_id', {\n        value: response.headers.get('request-id'),\n        enumerable: false,\n    });\n}\n//# sourceMappingURL=parse.mjs.map","import { ReadableStreamFrom } from \"./shims.mjs\";\nexport const checkFileSupport = () => {\n    if (typeof File === 'undefined') {\n        const { process } = globalThis;\n        const isOldNode = typeof process?.versions?.node === 'string' && parseInt(process.versions.node.split('.')) < 20;\n        throw new Error('`File` is not defined as a global, which is required for file uploads.' +\n            (isOldNode ?\n                \" Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`.\"\n                : ''));\n    }\n};\n/**\n * Construct a `File` instance. This is used to ensure a helpful error is thrown\n * for environments that don't define a global `File` yet.\n */\nexport function makeFile(fileBits, fileName, options) {\n    checkFileSupport();\n    return new File(fileBits, fileName ?? 'unknown_file', options);\n}\nexport function getName(value) {\n    return (((typeof value === 'object' &&\n        value !== null &&\n        (('name' in value && value.name && String(value.name)) ||\n            ('url' in value && value.url && String(value.url)) ||\n            ('filename' in value && value.filename && String(value.filename)) ||\n            ('path' in value && value.path && String(value.path)))) ||\n        '')\n        .split(/[\\\\/]/)\n        .pop() || undefined);\n}\nexport const isAsyncIterable = (value) => value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\nexport const maybeMultipartFormRequestOptions = async (opts, fetch) => {\n    if (!hasUploadableValue(opts.body))\n        return opts;\n    return { ...opts, body: await createForm(opts.body, fetch) };\n};\nexport const multipartFormRequestOptions = async (opts, fetch) => {\n    return { ...opts, body: await createForm(opts.body, fetch) };\n};\nconst supportsFormDataMap = new WeakMap();\n/**\n * node-fetch doesn't support the global FormData object in recent node versions. Instead of sending\n * properly-encoded form data, it just stringifies the object, resulting in a request body of \"[object FormData]\".\n * This function detects if the fetch function provided supports the global FormData object to avoid\n * confusing error messages later on.\n */\nfunction supportsFormData(fetchObject) {\n    const fetch = typeof fetchObject === 'function' ? fetchObject : fetchObject.fetch;\n    const cached = supportsFormDataMap.get(fetch);\n    if (cached)\n        return cached;\n    const promise = (async () => {\n        try {\n            const FetchResponse = ('Response' in fetch ?\n                fetch.Response\n                : (await fetch('data:,')).constructor);\n            const data = new FormData();\n            if (data.toString() === (await new FetchResponse(data).text())) {\n                return false;\n            }\n            return true;\n        }\n        catch {\n            // avoid false negatives\n            return true;\n        }\n    })();\n    supportsFormDataMap.set(fetch, promise);\n    return promise;\n}\nexport const createForm = async (body, fetch) => {\n    if (!(await supportsFormData(fetch))) {\n        throw new TypeError('The provided fetch function does not support file uploads with the current global FormData class.');\n    }\n    const form = new FormData();\n    await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n    return form;\n};\n// We check for Blob not File because Bun.File doesn't inherit from File,\n// but they both inherit from Blob and have a `name` property at runtime.\nconst isNamedBlob = (value) => value instanceof Blob && 'name' in value;\nconst isUploadable = (value) => typeof value === 'object' &&\n    value !== null &&\n    (value instanceof Response || isAsyncIterable(value) || isNamedBlob(value));\nconst hasUploadableValue = (value) => {\n    if (isUploadable(value))\n        return true;\n    if (Array.isArray(value))\n        return value.some(hasUploadableValue);\n    if (value && typeof value === 'object') {\n        for (const k in value) {\n            if (hasUploadableValue(value[k]))\n                return true;\n        }\n    }\n    return false;\n};\nconst addFormValue = async (form, key, value) => {\n    if (value === undefined)\n        return;\n    if (value == null) {\n        throw new TypeError(`Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`);\n    }\n    // TODO: make nested formats configurable\n    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        form.append(key, String(value));\n    }\n    else if (value instanceof Response) {\n        let options = {};\n        const contentType = value.headers.get('Content-Type');\n        if (contentType) {\n            options = { type: contentType };\n        }\n        form.append(key, makeFile([await value.blob()], getName(value), options));\n    }\n    else if (isAsyncIterable(value)) {\n        form.append(key, makeFile([await new Response(ReadableStreamFrom(value)).blob()], getName(value)));\n    }\n    else if (isNamedBlob(value)) {\n        form.append(key, makeFile([value], getName(value), { type: value.type }));\n    }\n    else if (Array.isArray(value)) {\n        await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\n    }\n    else if (typeof value === 'object') {\n        await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));\n    }\n    else {\n        throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);\n    }\n};\n//# sourceMappingURL=uploads.mjs.map","import { getName, makeFile, isAsyncIterable } from \"./uploads.mjs\";\nimport { checkFileSupport } from \"./uploads.mjs\";\n/**\n * This check adds the arrayBuffer() method type because it is available and used at runtime\n */\nconst isBlobLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.size === 'number' &&\n    typeof value.type === 'string' &&\n    typeof value.text === 'function' &&\n    typeof value.slice === 'function' &&\n    typeof value.arrayBuffer === 'function';\n/**\n * This check adds the arrayBuffer() method type because it is available and used at runtime\n */\nconst isFileLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.name === 'string' &&\n    typeof value.lastModified === 'number' &&\n    isBlobLike(value);\nconst isResponseLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.url === 'string' &&\n    typeof value.blob === 'function';\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nexport async function toFile(value, name, options) {\n    checkFileSupport();\n    // If it's a promise, resolve it.\n    value = await value;\n    name || (name = getName(value));\n    // If we've been given a `File` we don't need to do anything if the name / options\n    // have not been customised.\n    if (isFileLike(value)) {\n        if (value instanceof File && name == null && options == null) {\n            return value;\n        }\n        return makeFile([await value.arrayBuffer()], name ?? value.name, {\n            type: value.type,\n            lastModified: value.lastModified,\n            ...options,\n        });\n    }\n    if (isResponseLike(value)) {\n        const blob = await value.blob();\n        name || (name = new URL(value.url).pathname.split(/[\\\\/]/).pop());\n        return makeFile(await getBytes(blob), name, options);\n    }\n    const parts = await getBytes(value);\n    if (!options?.type) {\n        const type = parts.find((part) => typeof part === 'object' && 'type' in part && part.type);\n        if (typeof type === 'string') {\n            options = { ...options, type };\n        }\n    }\n    return makeFile(parts, name, options);\n}\nasync function getBytes(value) {\n    let parts = [];\n    if (typeof value === 'string' ||\n        ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n        value instanceof ArrayBuffer) {\n        parts.push(value);\n    }\n    else if (isBlobLike(value)) {\n        parts.push(value instanceof Blob ? value : await value.arrayBuffer());\n    }\n    else if (isAsyncIterable(value) // includes Readable, ReadableStream, etc.\n    ) {\n        for await (const chunk of value) {\n            parts.push(...(await getBytes(chunk))); // TODO, consider validating?\n        }\n    }\n    else {\n        const constructor = value?.constructor?.name;\n        throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ''}${propsForError(value)}`);\n    }\n    return parts;\n}\nfunction propsForError(value) {\n    if (typeof value !== 'object' || value === null)\n        return '';\n    const props = Object.getOwnPropertyNames(value);\n    return `; props: [${props.map((p) => `\"${p}\"`).join(', ')}]`;\n}\n//# sourceMappingURL=to-file.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nexport class APIResource {\n    constructor(client) {\n        this._client = client;\n    }\n}\n//# sourceMappingURL=resource.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nconst brand_privateNullableHeaders = Symbol.for('brand.privateNullableHeaders');\nconst isArray = Array.isArray;\nfunction* iterateHeaders(headers) {\n    if (!headers)\n        return;\n    if (brand_privateNullableHeaders in headers) {\n        const { values, nulls } = headers;\n        yield* values.entries();\n        for (const name of nulls) {\n            yield [name, null];\n        }\n        return;\n    }\n    let shouldClear = false;\n    let iter;\n    if (headers instanceof Headers) {\n        iter = headers.entries();\n    }\n    else if (isArray(headers)) {\n        iter = headers;\n    }\n    else {\n        shouldClear = true;\n        iter = Object.entries(headers ?? {});\n    }\n    for (let row of iter) {\n        const name = row[0];\n        if (typeof name !== 'string')\n            throw new TypeError('expected header name to be a string');\n        const values = isArray(row[1]) ? row[1] : [row[1]];\n        let didClear = false;\n        for (const value of values) {\n            if (value === undefined)\n                continue;\n            // Objects keys always overwrite older headers, they never append.\n            // Yield a null to clear the header before adding the new values.\n            if (shouldClear && !didClear) {\n                didClear = true;\n                yield [name, null];\n            }\n            yield [name, value];\n        }\n    }\n}\nexport const buildHeaders = (newHeaders) => {\n    const targetHeaders = new Headers();\n    const nullHeaders = new Set();\n    for (const headers of newHeaders) {\n        const seenHeaders = new Set();\n        for (const [name, value] of iterateHeaders(headers)) {\n            const lowerName = name.toLowerCase();\n            if (!seenHeaders.has(lowerName)) {\n                targetHeaders.delete(name);\n                seenHeaders.add(lowerName);\n            }\n            if (value === null) {\n                targetHeaders.delete(name);\n                nullHeaders.add(lowerName);\n            }\n            else {\n                targetHeaders.append(name, value);\n                nullHeaders.delete(lowerName);\n            }\n        }\n    }\n    return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };\n};\nexport const isEmptyHeaders = (headers) => {\n    for (const _ of iterateHeaders(headers))\n        return false;\n    return true;\n};\n//# sourceMappingURL=headers.mjs.map","import { AnthropicError } from \"../../core/error.mjs\";\n/**\n * Percent-encode everything that isn't safe to have in a path without encoding safe chars.\n *\n * Taken from https://datatracker.ietf.org/doc/html/rfc3986#section-3.3:\n * > unreserved  = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n * > sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n * > pchar       = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n */\nexport function encodeURIPath(str) {\n    return str.replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);\n}\nexport const createPathTagFunction = (pathEncoder = encodeURIPath) => function path(statics, ...params) {\n    // If there are no params, no processing is needed.\n    if (statics.length === 1)\n        return statics[0];\n    let postPath = false;\n    const path = statics.reduce((previousValue, currentValue, index) => {\n        if (/[?#]/.test(currentValue)) {\n            postPath = true;\n        }\n        return (previousValue +\n            currentValue +\n            (index === params.length ? '' : (postPath ? encodeURIComponent : pathEncoder)(String(params[index]))));\n    }, '');\n    const pathOnly = path.split(/[?#]/, 1)[0];\n    const invalidSegments = [];\n    const invalidSegmentPattern = /(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)/gi;\n    let match;\n    // Find all invalid segments\n    while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {\n        invalidSegments.push({\n            start: match.index,\n            length: match[0].length,\n        });\n    }\n    if (invalidSegments.length > 0) {\n        let lastEnd = 0;\n        const underline = invalidSegments.reduce((acc, segment) => {\n            const spaces = ' '.repeat(segment.start - lastEnd);\n            const arrows = '^'.repeat(segment.length);\n            lastEnd = segment.start + segment.length;\n            return acc + spaces + arrows;\n        }, '');\n        throw new AnthropicError(`Path parameters result in path with invalid segments:\\n${path}\\n${underline}`);\n    }\n    return path;\n};\n/**\n * URI-encodes path params and ensures no unsafe /./ or /../ path segments are introduced.\n */\nexport const path = createPathTagFunction(encodeURIPath);\n//# sourceMappingURL=path.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../core/resource.mjs\";\nimport { Page } from \"../../core/pagination.mjs\";\nimport { buildHeaders } from \"../../internal/headers.mjs\";\nimport { multipartFormRequestOptions } from \"../../internal/uploads.mjs\";\nimport { path } from \"../../internal/utils/path.mjs\";\nexport class Files extends APIResource {\n    /**\n     * List Files\n     *\n     * @example\n     * ```ts\n     * // Automatically fetches more pages as needed.\n     * for await (const fileMetadata of client.beta.files.list()) {\n     *   // ...\n     * }\n     * ```\n     */\n    list(params = {}, options) {\n        const { betas, ...query } = params ?? {};\n        return this._client.getAPIList('/v1/files', (Page), {\n            query,\n            ...options,\n            headers: buildHeaders([\n                { 'anthropic-beta': [...(betas ?? []), 'files-api-2025-04-14'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * Delete File\n     *\n     * @example\n     * ```ts\n     * const deletedFile = await client.beta.files.delete(\n     *   'file_id',\n     * );\n     * ```\n     */\n    delete(fileID, params = {}, options) {\n        const { betas } = params ?? {};\n        return this._client.delete(path `/v1/files/${fileID}`, {\n            ...options,\n            headers: buildHeaders([\n                { 'anthropic-beta': [...(betas ?? []), 'files-api-2025-04-14'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * Download File\n     *\n     * @example\n     * ```ts\n     * const response = await client.beta.files.download(\n     *   'file_id',\n     * );\n     *\n     * const content = await response.blob();\n     * console.log(content);\n     * ```\n     */\n    download(fileID, params = {}, options) {\n        const { betas } = params ?? {};\n        return this._client.get(path `/v1/files/${fileID}/content`, {\n            ...options,\n            headers: buildHeaders([\n                {\n                    'anthropic-beta': [...(betas ?? []), 'files-api-2025-04-14'].toString(),\n                    Accept: 'application/binary',\n                },\n                options?.headers,\n            ]),\n            __binaryResponse: true,\n        });\n    }\n    /**\n     * Get File Metadata\n     *\n     * @example\n     * ```ts\n     * const fileMetadata =\n     *   await client.beta.files.retrieveMetadata('file_id');\n     * ```\n     */\n    retrieveMetadata(fileID, params = {}, options) {\n        const { betas } = params ?? {};\n        return this._client.get(path `/v1/files/${fileID}`, {\n            ...options,\n            headers: buildHeaders([\n                { 'anthropic-beta': [...(betas ?? []), 'files-api-2025-04-14'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * Upload File\n     *\n     * @example\n     * ```ts\n     * const fileMetadata = await client.beta.files.upload({\n     *   file: fs.createReadStream('path/to/file'),\n     * });\n     * ```\n     */\n    upload(params, options) {\n        const { betas, ...body } = params;\n        return this._client.post('/v1/files', multipartFormRequestOptions({\n            body,\n            ...options,\n            headers: buildHeaders([\n                { 'anthropic-beta': [...(betas ?? []), 'files-api-2025-04-14'].toString() },\n                options?.headers,\n            ]),\n        }, this._client));\n    }\n}\n//# sourceMappingURL=files.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../core/resource.mjs\";\nimport { Page } from \"../../core/pagination.mjs\";\nimport { buildHeaders } from \"../../internal/headers.mjs\";\nimport { path } from \"../../internal/utils/path.mjs\";\nexport class Models extends APIResource {\n    /**\n     * Get a specific model.\n     *\n     * The Models API response can be used to determine information about a specific\n     * model or resolve a model alias to a model ID.\n     *\n     * @example\n     * ```ts\n     * const betaModelInfo = await client.beta.models.retrieve(\n     *   'model_id',\n     * );\n     * ```\n     */\n    retrieve(modelID, params = {}, options) {\n        const { betas } = params ?? {};\n        return this._client.get(path `/v1/models/${modelID}?beta=true`, {\n            ...options,\n            headers: buildHeaders([\n                { ...(betas?.toString() != null ? { 'anthropic-beta': betas?.toString() } : undefined) },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * List available models.\n     *\n     * The Models API response can be used to determine which models are available for\n     * use in the API. More recently released models are listed first.\n     *\n     * @example\n     * ```ts\n     * // Automatically fetches more pages as needed.\n     * for await (const betaModelInfo of client.beta.models.list()) {\n     *   // ...\n     * }\n     * ```\n     */\n    list(params = {}, options) {\n        const { betas, ...query } = params ?? {};\n        return this._client.getAPIList('/v1/models?beta=true', (Page), {\n            query,\n            ...options,\n            headers: buildHeaders([\n                { ...(betas?.toString() != null ? { 'anthropic-beta': betas?.toString() } : undefined) },\n                options?.headers,\n            ]),\n        });\n    }\n}\n//# sourceMappingURL=models.mjs.map","import { AnthropicError } from \"../../core/error.mjs\";\nimport { ReadableStreamToAsyncIterable } from \"../shims.mjs\";\nimport { LineDecoder } from \"./line.mjs\";\nexport class JSONLDecoder {\n    constructor(iterator, controller) {\n        this.iterator = iterator;\n        this.controller = controller;\n    }\n    async *decoder() {\n        const lineDecoder = new LineDecoder();\n        for await (const chunk of this.iterator) {\n            for (const line of lineDecoder.decode(chunk)) {\n                yield JSON.parse(line);\n            }\n        }\n        for (const line of lineDecoder.flush()) {\n            yield JSON.parse(line);\n        }\n    }\n    [Symbol.asyncIterator]() {\n        return this.decoder();\n    }\n    static fromResponse(response, controller) {\n        if (!response.body) {\n            controller.abort();\n            if (typeof globalThis.navigator !== 'undefined' &&\n                globalThis.navigator.product === 'ReactNative') {\n                throw new AnthropicError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);\n            }\n            throw new AnthropicError(`Attempted to iterate over a response with no body`);\n        }\n        return new JSONLDecoder(ReadableStreamToAsyncIterable(response.body), controller);\n    }\n}\n//# sourceMappingURL=jsonl.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../core/resource.mjs\";\nimport { Page } from \"../../../core/pagination.mjs\";\nimport { buildHeaders } from \"../../../internal/headers.mjs\";\nimport { JSONLDecoder } from \"../../../internal/decoders/jsonl.mjs\";\nimport { AnthropicError } from \"../../../error.mjs\";\nimport { path } from \"../../../internal/utils/path.mjs\";\nexport class Batches extends APIResource {\n    /**\n     * Send a batch of Message creation requests.\n     *\n     * The Message Batches API can be used to process multiple Messages API requests at\n     * once. Once a Message Batch is created, it begins processing immediately. Batches\n     * can take up to 24 hours to complete.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const betaMessageBatch =\n     *   await client.beta.messages.batches.create({\n     *     requests: [\n     *       {\n     *         custom_id: 'my-custom-id-1',\n     *         params: {\n     *           max_tokens: 1024,\n     *           messages: [\n     *             { content: 'Hello, world', role: 'user' },\n     *           ],\n     *           model: 'claude-3-7-sonnet-20250219',\n     *         },\n     *       },\n     *     ],\n     *   });\n     * ```\n     */\n    create(params, options) {\n        const { betas, ...body } = params;\n        return this._client.post('/v1/messages/batches?beta=true', {\n            body,\n            ...options,\n            headers: buildHeaders([\n                { 'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * This endpoint is idempotent and can be used to poll for Message Batch\n     * completion. To access the results of a Message Batch, make a request to the\n     * `results_url` field in the response.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const betaMessageBatch =\n     *   await client.beta.messages.batches.retrieve(\n     *     'message_batch_id',\n     *   );\n     * ```\n     */\n    retrieve(messageBatchID, params = {}, options) {\n        const { betas } = params ?? {};\n        return this._client.get(path `/v1/messages/batches/${messageBatchID}?beta=true`, {\n            ...options,\n            headers: buildHeaders([\n                { 'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * List all Message Batches within a Workspace. Most recently created batches are\n     * returned first.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * // Automatically fetches more pages as needed.\n     * for await (const betaMessageBatch of client.beta.messages.batches.list()) {\n     *   // ...\n     * }\n     * ```\n     */\n    list(params = {}, options) {\n        const { betas, ...query } = params ?? {};\n        return this._client.getAPIList('/v1/messages/batches?beta=true', (Page), {\n            query,\n            ...options,\n            headers: buildHeaders([\n                { 'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * Delete a Message Batch.\n     *\n     * Message Batches can only be deleted once they've finished processing. If you'd\n     * like to delete an in-progress batch, you must first cancel it.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const betaDeletedMessageBatch =\n     *   await client.beta.messages.batches.delete(\n     *     'message_batch_id',\n     *   );\n     * ```\n     */\n    delete(messageBatchID, params = {}, options) {\n        const { betas } = params ?? {};\n        return this._client.delete(path `/v1/messages/batches/${messageBatchID}?beta=true`, {\n            ...options,\n            headers: buildHeaders([\n                { 'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * Batches may be canceled any time before processing ends. Once cancellation is\n     * initiated, the batch enters a `canceling` state, at which time the system may\n     * complete any in-progress, non-interruptible requests before finalizing\n     * cancellation.\n     *\n     * The number of canceled requests is specified in `request_counts`. To determine\n     * which requests were canceled, check the individual results within the batch.\n     * Note that cancellation may not result in any canceled requests if they were\n     * non-interruptible.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const betaMessageBatch =\n     *   await client.beta.messages.batches.cancel(\n     *     'message_batch_id',\n     *   );\n     * ```\n     */\n    cancel(messageBatchID, params = {}, options) {\n        const { betas } = params ?? {};\n        return this._client.post(path `/v1/messages/batches/${messageBatchID}/cancel?beta=true`, {\n            ...options,\n            headers: buildHeaders([\n                { 'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * Streams the results of a Message Batch as a `.jsonl` file.\n     *\n     * Each line in the file is a JSON object containing the result of a single request\n     * in the Message Batch. Results are not guaranteed to be in the same order as\n     * requests. Use the `custom_id` field to match results to requests.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const betaMessageBatchIndividualResponse =\n     *   await client.beta.messages.batches.results(\n     *     'message_batch_id',\n     *   );\n     * ```\n     */\n    async results(messageBatchID, params = {}, options) {\n        const batch = await this.retrieve(messageBatchID);\n        if (!batch.results_url) {\n            throw new AnthropicError(`No batch \\`results_url\\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);\n        }\n        const { betas } = params ?? {};\n        return this._client\n            .get(batch.results_url, {\n            ...options,\n            headers: buildHeaders([\n                {\n                    'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString(),\n                    Accept: 'application/binary',\n                },\n                options?.headers,\n            ]),\n            stream: true,\n            __binaryResponse: true,\n        })\n            ._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));\n    }\n}\n//# sourceMappingURL=batches.mjs.map","const tokenize = (input) => {\n    let current = 0;\n    let tokens = [];\n    while (current < input.length) {\n        let char = input[current];\n        if (char === '\\\\') {\n            current++;\n            continue;\n        }\n        if (char === '{') {\n            tokens.push({\n                type: 'brace',\n                value: '{',\n            });\n            current++;\n            continue;\n        }\n        if (char === '}') {\n            tokens.push({\n                type: 'brace',\n                value: '}',\n            });\n            current++;\n            continue;\n        }\n        if (char === '[') {\n            tokens.push({\n                type: 'paren',\n                value: '[',\n            });\n            current++;\n            continue;\n        }\n        if (char === ']') {\n            tokens.push({\n                type: 'paren',\n                value: ']',\n            });\n            current++;\n            continue;\n        }\n        if (char === ':') {\n            tokens.push({\n                type: 'separator',\n                value: ':',\n            });\n            current++;\n            continue;\n        }\n        if (char === ',') {\n            tokens.push({\n                type: 'delimiter',\n                value: ',',\n            });\n            current++;\n            continue;\n        }\n        if (char === '\"') {\n            let value = '';\n            let danglingQuote = false;\n            char = input[++current];\n            while (char !== '\"') {\n                if (current === input.length) {\n                    danglingQuote = true;\n                    break;\n                }\n                if (char === '\\\\') {\n                    current++;\n                    if (current === input.length) {\n                        danglingQuote = true;\n                        break;\n                    }\n                    value += char + input[current];\n                    char = input[++current];\n                }\n                else {\n                    value += char;\n                    char = input[++current];\n                }\n            }\n            char = input[++current];\n            if (!danglingQuote) {\n                tokens.push({\n                    type: 'string',\n                    value,\n                });\n            }\n            continue;\n        }\n        let WHITESPACE = /\\s/;\n        if (char && WHITESPACE.test(char)) {\n            current++;\n            continue;\n        }\n        let NUMBERS = /[0-9]/;\n        if ((char && NUMBERS.test(char)) || char === '-' || char === '.') {\n            let value = '';\n            if (char === '-') {\n                value += char;\n                char = input[++current];\n            }\n            while ((char && NUMBERS.test(char)) || char === '.') {\n                value += char;\n                char = input[++current];\n            }\n            tokens.push({\n                type: 'number',\n                value,\n            });\n            continue;\n        }\n        let LETTERS = /[a-z]/i;\n        if (char && LETTERS.test(char)) {\n            let value = '';\n            while (char && LETTERS.test(char)) {\n                if (current === input.length) {\n                    break;\n                }\n                value += char;\n                char = input[++current];\n            }\n            if (value == 'true' || value == 'false' || value === 'null') {\n                tokens.push({\n                    type: 'name',\n                    value,\n                });\n            }\n            else {\n                // unknown token, e.g. `nul` which isn't quite `null`\n                current++;\n                continue;\n            }\n            continue;\n        }\n        current++;\n    }\n    return tokens;\n}, strip = (tokens) => {\n    if (tokens.length === 0) {\n        return tokens;\n    }\n    let lastToken = tokens[tokens.length - 1];\n    switch (lastToken.type) {\n        case 'separator':\n            tokens = tokens.slice(0, tokens.length - 1);\n            return strip(tokens);\n            break;\n        case 'number':\n            let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];\n            if (lastCharacterOfLastToken === '.' || lastCharacterOfLastToken === '-') {\n                tokens = tokens.slice(0, tokens.length - 1);\n                return strip(tokens);\n            }\n        case 'string':\n            let tokenBeforeTheLastToken = tokens[tokens.length - 2];\n            if (tokenBeforeTheLastToken?.type === 'delimiter') {\n                tokens = tokens.slice(0, tokens.length - 1);\n                return strip(tokens);\n            }\n            else if (tokenBeforeTheLastToken?.type === 'brace' && tokenBeforeTheLastToken.value === '{') {\n                tokens = tokens.slice(0, tokens.length - 1);\n                return strip(tokens);\n            }\n            break;\n        case 'delimiter':\n            tokens = tokens.slice(0, tokens.length - 1);\n            return strip(tokens);\n            break;\n    }\n    return tokens;\n}, unstrip = (tokens) => {\n    let tail = [];\n    tokens.map((token) => {\n        if (token.type === 'brace') {\n            if (token.value === '{') {\n                tail.push('}');\n            }\n            else {\n                tail.splice(tail.lastIndexOf('}'), 1);\n            }\n        }\n        if (token.type === 'paren') {\n            if (token.value === '[') {\n                tail.push(']');\n            }\n            else {\n                tail.splice(tail.lastIndexOf(']'), 1);\n            }\n        }\n    });\n    if (tail.length > 0) {\n        tail.reverse().map((item) => {\n            if (item === '}') {\n                tokens.push({\n                    type: 'brace',\n                    value: '}',\n                });\n            }\n            else if (item === ']') {\n                tokens.push({\n                    type: 'paren',\n                    value: ']',\n                });\n            }\n        });\n    }\n    return tokens;\n}, generate = (tokens) => {\n    let output = '';\n    tokens.map((token) => {\n        switch (token.type) {\n            case 'string':\n                output += '\"' + token.value + '\"';\n                break;\n            default:\n                output += token.value;\n                break;\n        }\n    });\n    return output;\n}, partialParse = (input) => JSON.parse(generate(unstrip(strip(tokenize(input)))));\nexport { partialParse };\n//# sourceMappingURL=parser.mjs.map","var _BetaMessageStream_instances, _BetaMessageStream_currentMessageSnapshot, _BetaMessageStream_connectedPromise, _BetaMessageStream_resolveConnectedPromise, _BetaMessageStream_rejectConnectedPromise, _BetaMessageStream_endPromise, _BetaMessageStream_resolveEndPromise, _BetaMessageStream_rejectEndPromise, _BetaMessageStream_listeners, _BetaMessageStream_ended, _BetaMessageStream_errored, _BetaMessageStream_aborted, _BetaMessageStream_catchingPromiseCreated, _BetaMessageStream_response, _BetaMessageStream_request_id, _BetaMessageStream_getFinalMessage, _BetaMessageStream_getFinalText, _BetaMessageStream_handleError, _BetaMessageStream_beginRequest, _BetaMessageStream_addStreamEvent, _BetaMessageStream_endRequest, _BetaMessageStream_accumulateMessage;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"../internal/tslib.mjs\";\nimport { isAbortError } from \"../internal/errors.mjs\";\nimport { AnthropicError, APIUserAbortError } from \"../error.mjs\";\nimport { Stream } from \"../streaming.mjs\";\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.mjs\";\nconst JSON_BUF_PROPERTY = '__json_buf';\nfunction tracksToolInput(content) {\n    return content.type === 'tool_use' || content.type === 'server_tool_use' || content.type === 'mcp_tool_use';\n}\nexport class BetaMessageStream {\n    constructor() {\n        _BetaMessageStream_instances.add(this);\n        this.messages = [];\n        this.receivedMessages = [];\n        _BetaMessageStream_currentMessageSnapshot.set(this, void 0);\n        this.controller = new AbortController();\n        _BetaMessageStream_connectedPromise.set(this, void 0);\n        _BetaMessageStream_resolveConnectedPromise.set(this, () => { });\n        _BetaMessageStream_rejectConnectedPromise.set(this, () => { });\n        _BetaMessageStream_endPromise.set(this, void 0);\n        _BetaMessageStream_resolveEndPromise.set(this, () => { });\n        _BetaMessageStream_rejectEndPromise.set(this, () => { });\n        _BetaMessageStream_listeners.set(this, {});\n        _BetaMessageStream_ended.set(this, false);\n        _BetaMessageStream_errored.set(this, false);\n        _BetaMessageStream_aborted.set(this, false);\n        _BetaMessageStream_catchingPromiseCreated.set(this, false);\n        _BetaMessageStream_response.set(this, void 0);\n        _BetaMessageStream_request_id.set(this, void 0);\n        _BetaMessageStream_handleError.set(this, (error) => {\n            __classPrivateFieldSet(this, _BetaMessageStream_errored, true, \"f\");\n            if (isAbortError(error)) {\n                error = new APIUserAbortError();\n            }\n            if (error instanceof APIUserAbortError) {\n                __classPrivateFieldSet(this, _BetaMessageStream_aborted, true, \"f\");\n                return this._emit('abort', error);\n            }\n            if (error instanceof AnthropicError) {\n                return this._emit('error', error);\n            }\n            if (error instanceof Error) {\n                const anthropicError = new AnthropicError(error.message);\n                // @ts-ignore\n                anthropicError.cause = error;\n                return this._emit('error', anthropicError);\n            }\n            return this._emit('error', new AnthropicError(String(error)));\n        });\n        __classPrivateFieldSet(this, _BetaMessageStream_connectedPromise, new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _BetaMessageStream_resolveConnectedPromise, resolve, \"f\");\n            __classPrivateFieldSet(this, _BetaMessageStream_rejectConnectedPromise, reject, \"f\");\n        }), \"f\");\n        __classPrivateFieldSet(this, _BetaMessageStream_endPromise, new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _BetaMessageStream_resolveEndPromise, resolve, \"f\");\n            __classPrivateFieldSet(this, _BetaMessageStream_rejectEndPromise, reject, \"f\");\n        }), \"f\");\n        // Don't let these promises cause unhandled rejection errors.\n        // we will manually cause an unhandled rejection error later\n        // if the user hasn't registered any error listener or called\n        // any promise-returning method.\n        __classPrivateFieldGet(this, _BetaMessageStream_connectedPromise, \"f\").catch(() => { });\n        __classPrivateFieldGet(this, _BetaMessageStream_endPromise, \"f\").catch(() => { });\n    }\n    get response() {\n        return __classPrivateFieldGet(this, _BetaMessageStream_response, \"f\");\n    }\n    get request_id() {\n        return __classPrivateFieldGet(this, _BetaMessageStream_request_id, \"f\");\n    }\n    /**\n     * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,\n     * returned vie the `request-id` header which is useful for debugging requests and resporting\n     * issues to Anthropic.\n     *\n     * This is the same as the `APIPromise.withResponse()` method.\n     *\n     * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`\n     * as no `Response` is available.\n     */\n    async withResponse() {\n        const response = await __classPrivateFieldGet(this, _BetaMessageStream_connectedPromise, \"f\");\n        if (!response) {\n            throw new Error('Could not resolve a `Response` object');\n        }\n        return {\n            data: this,\n            response,\n            request_id: response.headers.get('request-id'),\n        };\n    }\n    /**\n     * Intended for use on the frontend, consuming a stream produced with\n     * `.toReadableStream()` on the backend.\n     *\n     * Note that messages sent to the model do not appear in `.on('message')`\n     * in this context.\n     */\n    static fromReadableStream(stream) {\n        const runner = new BetaMessageStream();\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    static createMessage(messages, params, options) {\n        const runner = new BetaMessageStream();\n        for (const message of params.messages) {\n            runner._addMessageParam(message);\n        }\n        runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } }));\n        return runner;\n    }\n    _run(executor) {\n        executor().then(() => {\n            this._emitFinal();\n            this._emit('end');\n        }, __classPrivateFieldGet(this, _BetaMessageStream_handleError, \"f\"));\n    }\n    _addMessageParam(message) {\n        this.messages.push(message);\n    }\n    _addMessage(message, emit = true) {\n        this.receivedMessages.push(message);\n        if (emit) {\n            this._emit('message', message);\n        }\n    }\n    async _createMessage(messages, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_beginRequest).call(this);\n        const { response, data: stream } = await messages\n            .create({ ...params, stream: true }, { ...options, signal: this.controller.signal })\n            .withResponse();\n        this._connected(response);\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_addStreamEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_endRequest).call(this);\n    }\n    _connected(response) {\n        if (this.ended)\n            return;\n        __classPrivateFieldSet(this, _BetaMessageStream_response, response, \"f\");\n        __classPrivateFieldSet(this, _BetaMessageStream_request_id, response?.headers.get('request-id'), \"f\");\n        __classPrivateFieldGet(this, _BetaMessageStream_resolveConnectedPromise, \"f\").call(this, response);\n        this._emit('connect');\n    }\n    get ended() {\n        return __classPrivateFieldGet(this, _BetaMessageStream_ended, \"f\");\n    }\n    get errored() {\n        return __classPrivateFieldGet(this, _BetaMessageStream_errored, \"f\");\n    }\n    get aborted() {\n        return __classPrivateFieldGet(this, _BetaMessageStream_aborted, \"f\");\n    }\n    abort() {\n        this.controller.abort();\n    }\n    /**\n     * Adds the listener function to the end of the listeners array for the event.\n     * No checks are made to see if the listener has already been added. Multiple calls passing\n     * the same combination of event and listener will result in the listener being added, and\n     * called, multiple times.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    on(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener });\n        return this;\n    }\n    /**\n     * Removes the specified listener from the listener array for the event.\n     * off() will remove, at most, one instance of a listener from the listener array. If any single\n     * listener has been added multiple times to the listener array for the specified event, then\n     * off() must be called multiple times to remove each instance.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    off(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event];\n        if (!listeners)\n            return this;\n        const index = listeners.findIndex((l) => l.listener === listener);\n        if (index >= 0)\n            listeners.splice(index, 1);\n        return this;\n    }\n    /**\n     * Adds a one-time listener function for the event. The next time the event is triggered,\n     * this listener is removed and then invoked.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    once(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener, once: true });\n        return this;\n    }\n    /**\n     * This is similar to `.once()`, but returns a Promise that resolves the next time\n     * the event is triggered, instead of calling a listener callback.\n     * @returns a Promise that resolves the next time given event is triggered,\n     * or rejects if an error is emitted.  (If you request the 'error' event,\n     * returns a promise that resolves with the error).\n     *\n     * Example:\n     *\n     *   const message = await stream.emitted('message') // rejects if the stream errors\n     */\n    emitted(event) {\n        return new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _BetaMessageStream_catchingPromiseCreated, true, \"f\");\n            if (event !== 'error')\n                this.once('error', reject);\n            this.once(event, resolve);\n        });\n    }\n    async done() {\n        __classPrivateFieldSet(this, _BetaMessageStream_catchingPromiseCreated, true, \"f\");\n        await __classPrivateFieldGet(this, _BetaMessageStream_endPromise, \"f\");\n    }\n    get currentMessage() {\n        return __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, \"f\");\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant Message response,\n     * or rejects if an error occurred or the stream ended prematurely without producing a Message.\n     */\n    async finalMessage() {\n        await this.done();\n        return __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_getFinalMessage).call(this);\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant Message's text response, concatenated\n     * together if there are more than one text blocks.\n     * Rejects if an error occurred or the stream ended prematurely without producing a Message.\n     */\n    async finalText() {\n        await this.done();\n        return __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_getFinalText).call(this);\n    }\n    _emit(event, ...args) {\n        // make sure we don't emit any MessageStreamEvents after end\n        if (__classPrivateFieldGet(this, _BetaMessageStream_ended, \"f\"))\n            return;\n        if (event === 'end') {\n            __classPrivateFieldSet(this, _BetaMessageStream_ended, true, \"f\");\n            __classPrivateFieldGet(this, _BetaMessageStream_resolveEndPromise, \"f\").call(this);\n        }\n        const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event];\n        if (listeners) {\n            __classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event] = listeners.filter((l) => !l.once);\n            listeners.forEach(({ listener }) => listener(...args));\n        }\n        if (event === 'abort') {\n            const error = args[0];\n            if (!__classPrivateFieldGet(this, _BetaMessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                Promise.reject(error);\n            }\n            __classPrivateFieldGet(this, _BetaMessageStream_rejectConnectedPromise, \"f\").call(this, error);\n            __classPrivateFieldGet(this, _BetaMessageStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n            return;\n        }\n        if (event === 'error') {\n            // NOTE: _emit('error', error) should only be called from #handleError().\n            const error = args[0];\n            if (!__classPrivateFieldGet(this, _BetaMessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n                // If you are seeing stack traces here, make sure to handle errors via either:\n                // - runner.on('error', () => ...)\n                // - await runner.done()\n                // - await runner.final...()\n                // - etc.\n                Promise.reject(error);\n            }\n            __classPrivateFieldGet(this, _BetaMessageStream_rejectConnectedPromise, \"f\").call(this, error);\n            __classPrivateFieldGet(this, _BetaMessageStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n        }\n    }\n    _emitFinal() {\n        const finalMessage = this.receivedMessages.at(-1);\n        if (finalMessage) {\n            this._emit('finalMessage', __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_getFinalMessage).call(this));\n        }\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_beginRequest).call(this);\n        this._connected(null);\n        const stream = Stream.fromReadableStream(readableStream, this.controller);\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_addStreamEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_endRequest).call(this);\n    }\n    [(_BetaMessageStream_currentMessageSnapshot = new WeakMap(), _BetaMessageStream_connectedPromise = new WeakMap(), _BetaMessageStream_resolveConnectedPromise = new WeakMap(), _BetaMessageStream_rejectConnectedPromise = new WeakMap(), _BetaMessageStream_endPromise = new WeakMap(), _BetaMessageStream_resolveEndPromise = new WeakMap(), _BetaMessageStream_rejectEndPromise = new WeakMap(), _BetaMessageStream_listeners = new WeakMap(), _BetaMessageStream_ended = new WeakMap(), _BetaMessageStream_errored = new WeakMap(), _BetaMessageStream_aborted = new WeakMap(), _BetaMessageStream_catchingPromiseCreated = new WeakMap(), _BetaMessageStream_response = new WeakMap(), _BetaMessageStream_request_id = new WeakMap(), _BetaMessageStream_handleError = new WeakMap(), _BetaMessageStream_instances = new WeakSet(), _BetaMessageStream_getFinalMessage = function _BetaMessageStream_getFinalMessage() {\n        if (this.receivedMessages.length === 0) {\n            throw new AnthropicError('stream ended without producing a Message with role=assistant');\n        }\n        return this.receivedMessages.at(-1);\n    }, _BetaMessageStream_getFinalText = function _BetaMessageStream_getFinalText() {\n        if (this.receivedMessages.length === 0) {\n            throw new AnthropicError('stream ended without producing a Message with role=assistant');\n        }\n        const textBlocks = this.receivedMessages\n            .at(-1)\n            .content.filter((block) => block.type === 'text')\n            .map((block) => block.text);\n        if (textBlocks.length === 0) {\n            throw new AnthropicError('stream ended without producing a content block with type=text');\n        }\n        return textBlocks.join(' ');\n    }, _BetaMessageStream_beginRequest = function _BetaMessageStream_beginRequest() {\n        if (this.ended)\n            return;\n        __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, undefined, \"f\");\n    }, _BetaMessageStream_addStreamEvent = function _BetaMessageStream_addStreamEvent(event) {\n        if (this.ended)\n            return;\n        const messageSnapshot = __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_accumulateMessage).call(this, event);\n        this._emit('streamEvent', event, messageSnapshot);\n        switch (event.type) {\n            case 'content_block_delta': {\n                const content = messageSnapshot.content.at(-1);\n                switch (event.delta.type) {\n                    case 'text_delta': {\n                        if (content.type === 'text') {\n                            this._emit('text', event.delta.text, content.text || '');\n                        }\n                        break;\n                    }\n                    case 'citations_delta': {\n                        if (content.type === 'text') {\n                            this._emit('citation', event.delta.citation, content.citations ?? []);\n                        }\n                        break;\n                    }\n                    case 'input_json_delta': {\n                        if (tracksToolInput(content) && content.input) {\n                            this._emit('inputJson', event.delta.partial_json, content.input);\n                        }\n                        break;\n                    }\n                    case 'thinking_delta': {\n                        if (content.type === 'thinking') {\n                            this._emit('thinking', event.delta.thinking, content.thinking);\n                        }\n                        break;\n                    }\n                    case 'signature_delta': {\n                        if (content.type === 'thinking') {\n                            this._emit('signature', content.signature);\n                        }\n                        break;\n                    }\n                    default:\n                        checkNever(event.delta);\n                }\n                break;\n            }\n            case 'message_stop': {\n                this._addMessageParam(messageSnapshot);\n                this._addMessage(messageSnapshot, true);\n                break;\n            }\n            case 'content_block_stop': {\n                this._emit('contentBlock', messageSnapshot.content.at(-1));\n                break;\n            }\n            case 'message_start': {\n                __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, messageSnapshot, \"f\");\n                break;\n            }\n            case 'content_block_start':\n            case 'message_delta':\n                break;\n        }\n    }, _BetaMessageStream_endRequest = function _BetaMessageStream_endRequest() {\n        if (this.ended) {\n            throw new AnthropicError(`stream has ended, this shouldn't happen`);\n        }\n        const snapshot = __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, \"f\");\n        if (!snapshot) {\n            throw new AnthropicError(`request ended without sending any chunks`);\n        }\n        __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, undefined, \"f\");\n        return snapshot;\n    }, _BetaMessageStream_accumulateMessage = function _BetaMessageStream_accumulateMessage(event) {\n        let snapshot = __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, \"f\");\n        if (event.type === 'message_start') {\n            if (snapshot) {\n                throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\n            }\n            return event.message;\n        }\n        if (!snapshot) {\n            throw new AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\n        }\n        switch (event.type) {\n            case 'message_stop':\n                return snapshot;\n            case 'message_delta':\n                snapshot.container = event.delta.container;\n                snapshot.stop_reason = event.delta.stop_reason;\n                snapshot.stop_sequence = event.delta.stop_sequence;\n                snapshot.usage.output_tokens = event.usage.output_tokens;\n                if (event.usage.input_tokens != null) {\n                    snapshot.usage.input_tokens = event.usage.input_tokens;\n                }\n                if (event.usage.cache_creation_input_tokens != null) {\n                    snapshot.usage.cache_creation_input_tokens = event.usage.cache_creation_input_tokens;\n                }\n                if (event.usage.cache_read_input_tokens != null) {\n                    snapshot.usage.cache_read_input_tokens = event.usage.cache_read_input_tokens;\n                }\n                if (event.usage.server_tool_use != null) {\n                    snapshot.usage.server_tool_use = event.usage.server_tool_use;\n                }\n                return snapshot;\n            case 'content_block_start':\n                snapshot.content.push(event.content_block);\n                return snapshot;\n            case 'content_block_delta': {\n                const snapshotContent = snapshot.content.at(event.index);\n                switch (event.delta.type) {\n                    case 'text_delta': {\n                        if (snapshotContent?.type === 'text') {\n                            snapshotContent.text += event.delta.text;\n                        }\n                        break;\n                    }\n                    case 'citations_delta': {\n                        if (snapshotContent?.type === 'text') {\n                            snapshotContent.citations ?? (snapshotContent.citations = []);\n                            snapshotContent.citations.push(event.delta.citation);\n                        }\n                        break;\n                    }\n                    case 'input_json_delta': {\n                        if (snapshotContent && tracksToolInput(snapshotContent)) {\n                            // we need to keep track of the raw JSON string as well so that we can\n                            // re-parse it for each delta, for now we just store it as an untyped\n                            // non-enumerable property on the snapshot\n                            let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || '';\n                            jsonBuf += event.delta.partial_json;\n                            Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {\n                                value: jsonBuf,\n                                enumerable: false,\n                                writable: true,\n                            });\n                            if (jsonBuf) {\n                                snapshotContent.input = partialParse(jsonBuf);\n                            }\n                        }\n                        break;\n                    }\n                    case 'thinking_delta': {\n                        if (snapshotContent?.type === 'thinking') {\n                            snapshotContent.thinking += event.delta.thinking;\n                        }\n                        break;\n                    }\n                    case 'signature_delta': {\n                        if (snapshotContent?.type === 'thinking') {\n                            snapshotContent.signature = event.delta.signature;\n                        }\n                        break;\n                    }\n                    default:\n                        checkNever(event.delta);\n                }\n                return snapshot;\n            }\n            case 'content_block_stop':\n                return snapshot;\n        }\n    }, Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        this.on('streamEvent', (event) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(event);\n            }\n            else {\n                pushQueue.push(event);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                }\n                const chunk = pushQueue.shift();\n                return { value: chunk, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    toReadableStream() {\n        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n}\n// used to ensure exhaustive case matching without throwing a runtime error\nfunction checkNever(x) { }\n//# sourceMappingURL=BetaMessageStream.mjs.map","// File containing shared constants\n/**\n * Model-specific timeout constraints for non-streaming requests\n */\nexport const MODEL_NONSTREAMING_TOKENS = {\n    'claude-opus-4-20250514': 8192,\n    'claude-opus-4-0': 8192,\n    'claude-4-opus-20250514': 8192,\n    'anthropic.claude-opus-4-20250514-v1:0': 8192,\n    'claude-opus-4@20250514': 8192,\n};\n//# sourceMappingURL=constants.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../core/resource.mjs\";\nimport * as BatchesAPI from \"./batches.mjs\";\nimport { Batches, } from \"./batches.mjs\";\nimport { buildHeaders } from \"../../../internal/headers.mjs\";\nimport { BetaMessageStream } from \"../../../lib/BetaMessageStream.mjs\";\nconst DEPRECATED_MODELS = {\n    'claude-1.3': 'November 6th, 2024',\n    'claude-1.3-100k': 'November 6th, 2024',\n    'claude-instant-1.1': 'November 6th, 2024',\n    'claude-instant-1.1-100k': 'November 6th, 2024',\n    'claude-instant-1.2': 'November 6th, 2024',\n    'claude-3-sonnet-20240229': 'July 21st, 2025',\n    'claude-2.1': 'July 21st, 2025',\n    'claude-2.0': 'July 21st, 2025',\n};\nimport { MODEL_NONSTREAMING_TOKENS } from \"../../../internal/constants.mjs\";\nexport class Messages extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.batches = new BatchesAPI.Batches(this._client);\n    }\n    create(params, options) {\n        const { betas, ...body } = params;\n        if (body.model in DEPRECATED_MODELS) {\n            console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}\\nPlease migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);\n        }\n        let timeout = this._client._options.timeout;\n        if (!body.stream && timeout == null) {\n            const maxNonstreamingTokens = MODEL_NONSTREAMING_TOKENS[body.model] ?? undefined;\n            timeout = this._client.calculateNonstreamingTimeout(body.max_tokens, maxNonstreamingTokens);\n        }\n        return this._client.post('/v1/messages?beta=true', {\n            body,\n            timeout: timeout ?? 600000,\n            ...options,\n            headers: buildHeaders([\n                { ...(betas?.toString() != null ? { 'anthropic-beta': betas?.toString() } : undefined) },\n                options?.headers,\n            ]),\n            stream: params.stream ?? false,\n        });\n    }\n    /**\n     * Create a Message stream\n     */\n    stream(body, options) {\n        return BetaMessageStream.createMessage(this, body, options);\n    }\n    /**\n     * Count the number of tokens in a Message.\n     *\n     * The Token Count API can be used to count the number of tokens in a Message,\n     * including tools, images, and documents, without creating it.\n     *\n     * Learn more about token counting in our\n     * [user guide](/en/docs/build-with-claude/token-counting)\n     *\n     * @example\n     * ```ts\n     * const betaMessageTokensCount =\n     *   await client.beta.messages.countTokens({\n     *     messages: [{ content: 'string', role: 'user' }],\n     *     model: 'claude-3-7-sonnet-latest',\n     *   });\n     * ```\n     */\n    countTokens(params, options) {\n        const { betas, ...body } = params;\n        return this._client.post('/v1/messages/count_tokens?beta=true', {\n            body,\n            ...options,\n            headers: buildHeaders([\n                { 'anthropic-beta': [...(betas ?? []), 'token-counting-2024-11-01'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n}\nMessages.Batches = Batches;\n//# sourceMappingURL=messages.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../core/resource.mjs\";\nimport * as FilesAPI from \"./files.mjs\";\nimport { Files, } from \"./files.mjs\";\nimport * as ModelsAPI from \"./models.mjs\";\nimport { Models } from \"./models.mjs\";\nimport * as MessagesAPI from \"./messages/messages.mjs\";\nimport { Messages, } from \"./messages/messages.mjs\";\nexport class Beta extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.models = new ModelsAPI.Models(this._client);\n        this.messages = new MessagesAPI.Messages(this._client);\n        this.files = new FilesAPI.Files(this._client);\n    }\n}\nBeta.Models = Models;\nBeta.Messages = Messages;\nBeta.Files = Files;\n//# sourceMappingURL=beta.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../core/resource.mjs\";\nimport { buildHeaders } from \"../internal/headers.mjs\";\nexport class Completions extends APIResource {\n    create(params, options) {\n        const { betas, ...body } = params;\n        return this._client.post('/v1/complete', {\n            body,\n            timeout: this._client._options.timeout ?? 600000,\n            ...options,\n            headers: buildHeaders([\n                { ...(betas?.toString() != null ? { 'anthropic-beta': betas?.toString() } : undefined) },\n                options?.headers,\n            ]),\n            stream: params.stream ?? false,\n        });\n    }\n}\n//# sourceMappingURL=completions.mjs.map","var _MessageStream_instances, _MessageStream_currentMessageSnapshot, _MessageStream_connectedPromise, _MessageStream_resolveConnectedPromise, _MessageStream_rejectConnectedPromise, _MessageStream_endPromise, _MessageStream_resolveEndPromise, _MessageStream_rejectEndPromise, _MessageStream_listeners, _MessageStream_ended, _MessageStream_errored, _MessageStream_aborted, _MessageStream_catchingPromiseCreated, _MessageStream_response, _MessageStream_request_id, _MessageStream_getFinalMessage, _MessageStream_getFinalText, _MessageStream_handleError, _MessageStream_beginRequest, _MessageStream_addStreamEvent, _MessageStream_endRequest, _MessageStream_accumulateMessage;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"../internal/tslib.mjs\";\nimport { isAbortError } from \"../internal/errors.mjs\";\nimport { AnthropicError, APIUserAbortError } from \"../error.mjs\";\nimport { Stream } from \"../streaming.mjs\";\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.mjs\";\nconst JSON_BUF_PROPERTY = '__json_buf';\nfunction tracksToolInput(content) {\n    return content.type === 'tool_use' || content.type === 'server_tool_use';\n}\nexport class MessageStream {\n    constructor() {\n        _MessageStream_instances.add(this);\n        this.messages = [];\n        this.receivedMessages = [];\n        _MessageStream_currentMessageSnapshot.set(this, void 0);\n        this.controller = new AbortController();\n        _MessageStream_connectedPromise.set(this, void 0);\n        _MessageStream_resolveConnectedPromise.set(this, () => { });\n        _MessageStream_rejectConnectedPromise.set(this, () => { });\n        _MessageStream_endPromise.set(this, void 0);\n        _MessageStream_resolveEndPromise.set(this, () => { });\n        _MessageStream_rejectEndPromise.set(this, () => { });\n        _MessageStream_listeners.set(this, {});\n        _MessageStream_ended.set(this, false);\n        _MessageStream_errored.set(this, false);\n        _MessageStream_aborted.set(this, false);\n        _MessageStream_catchingPromiseCreated.set(this, false);\n        _MessageStream_response.set(this, void 0);\n        _MessageStream_request_id.set(this, void 0);\n        _MessageStream_handleError.set(this, (error) => {\n            __classPrivateFieldSet(this, _MessageStream_errored, true, \"f\");\n            if (isAbortError(error)) {\n                error = new APIUserAbortError();\n            }\n            if (error instanceof APIUserAbortError) {\n                __classPrivateFieldSet(this, _MessageStream_aborted, true, \"f\");\n                return this._emit('abort', error);\n            }\n            if (error instanceof AnthropicError) {\n                return this._emit('error', error);\n            }\n            if (error instanceof Error) {\n                const anthropicError = new AnthropicError(error.message);\n                // @ts-ignore\n                anthropicError.cause = error;\n                return this._emit('error', anthropicError);\n            }\n            return this._emit('error', new AnthropicError(String(error)));\n        });\n        __classPrivateFieldSet(this, _MessageStream_connectedPromise, new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _MessageStream_resolveConnectedPromise, resolve, \"f\");\n            __classPrivateFieldSet(this, _MessageStream_rejectConnectedPromise, reject, \"f\");\n        }), \"f\");\n        __classPrivateFieldSet(this, _MessageStream_endPromise, new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _MessageStream_resolveEndPromise, resolve, \"f\");\n            __classPrivateFieldSet(this, _MessageStream_rejectEndPromise, reject, \"f\");\n        }), \"f\");\n        // Don't let these promises cause unhandled rejection errors.\n        // we will manually cause an unhandled rejection error later\n        // if the user hasn't registered any error listener or called\n        // any promise-returning method.\n        __classPrivateFieldGet(this, _MessageStream_connectedPromise, \"f\").catch(() => { });\n        __classPrivateFieldGet(this, _MessageStream_endPromise, \"f\").catch(() => { });\n    }\n    get response() {\n        return __classPrivateFieldGet(this, _MessageStream_response, \"f\");\n    }\n    get request_id() {\n        return __classPrivateFieldGet(this, _MessageStream_request_id, \"f\");\n    }\n    /**\n     * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,\n     * returned vie the `request-id` header which is useful for debugging requests and resporting\n     * issues to Anthropic.\n     *\n     * This is the same as the `APIPromise.withResponse()` method.\n     *\n     * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`\n     * as no `Response` is available.\n     */\n    async withResponse() {\n        const response = await __classPrivateFieldGet(this, _MessageStream_connectedPromise, \"f\");\n        if (!response) {\n            throw new Error('Could not resolve a `Response` object');\n        }\n        return {\n            data: this,\n            response,\n            request_id: response.headers.get('request-id'),\n        };\n    }\n    /**\n     * Intended for use on the frontend, consuming a stream produced with\n     * `.toReadableStream()` on the backend.\n     *\n     * Note that messages sent to the model do not appear in `.on('message')`\n     * in this context.\n     */\n    static fromReadableStream(stream) {\n        const runner = new MessageStream();\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    static createMessage(messages, params, options) {\n        const runner = new MessageStream();\n        for (const message of params.messages) {\n            runner._addMessageParam(message);\n        }\n        runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } }));\n        return runner;\n    }\n    _run(executor) {\n        executor().then(() => {\n            this._emitFinal();\n            this._emit('end');\n        }, __classPrivateFieldGet(this, _MessageStream_handleError, \"f\"));\n    }\n    _addMessageParam(message) {\n        this.messages.push(message);\n    }\n    _addMessage(message, emit = true) {\n        this.receivedMessages.push(message);\n        if (emit) {\n            this._emit('message', message);\n        }\n    }\n    async _createMessage(messages, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_beginRequest).call(this);\n        const { response, data: stream } = await messages\n            .create({ ...params, stream: true }, { ...options, signal: this.controller.signal })\n            .withResponse();\n        this._connected(response);\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_addStreamEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_endRequest).call(this);\n    }\n    _connected(response) {\n        if (this.ended)\n            return;\n        __classPrivateFieldSet(this, _MessageStream_response, response, \"f\");\n        __classPrivateFieldSet(this, _MessageStream_request_id, response?.headers.get('request-id'), \"f\");\n        __classPrivateFieldGet(this, _MessageStream_resolveConnectedPromise, \"f\").call(this, response);\n        this._emit('connect');\n    }\n    get ended() {\n        return __classPrivateFieldGet(this, _MessageStream_ended, \"f\");\n    }\n    get errored() {\n        return __classPrivateFieldGet(this, _MessageStream_errored, \"f\");\n    }\n    get aborted() {\n        return __classPrivateFieldGet(this, _MessageStream_aborted, \"f\");\n    }\n    abort() {\n        this.controller.abort();\n    }\n    /**\n     * Adds the listener function to the end of the listeners array for the event.\n     * No checks are made to see if the listener has already been added. Multiple calls passing\n     * the same combination of event and listener will result in the listener being added, and\n     * called, multiple times.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    on(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener });\n        return this;\n    }\n    /**\n     * Removes the specified listener from the listener array for the event.\n     * off() will remove, at most, one instance of a listener from the listener array. If any single\n     * listener has been added multiple times to the listener array for the specified event, then\n     * off() must be called multiple times to remove each instance.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    off(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event];\n        if (!listeners)\n            return this;\n        const index = listeners.findIndex((l) => l.listener === listener);\n        if (index >= 0)\n            listeners.splice(index, 1);\n        return this;\n    }\n    /**\n     * Adds a one-time listener function for the event. The next time the event is triggered,\n     * this listener is removed and then invoked.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    once(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener, once: true });\n        return this;\n    }\n    /**\n     * This is similar to `.once()`, but returns a Promise that resolves the next time\n     * the event is triggered, instead of calling a listener callback.\n     * @returns a Promise that resolves the next time given event is triggered,\n     * or rejects if an error is emitted.  (If you request the 'error' event,\n     * returns a promise that resolves with the error).\n     *\n     * Example:\n     *\n     *   const message = await stream.emitted('message') // rejects if the stream errors\n     */\n    emitted(event) {\n        return new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, \"f\");\n            if (event !== 'error')\n                this.once('error', reject);\n            this.once(event, resolve);\n        });\n    }\n    async done() {\n        __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, \"f\");\n        await __classPrivateFieldGet(this, _MessageStream_endPromise, \"f\");\n    }\n    get currentMessage() {\n        return __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, \"f\");\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant Message response,\n     * or rejects if an error occurred or the stream ended prematurely without producing a Message.\n     */\n    async finalMessage() {\n        await this.done();\n        return __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_getFinalMessage).call(this);\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant Message's text response, concatenated\n     * together if there are more than one text blocks.\n     * Rejects if an error occurred or the stream ended prematurely without producing a Message.\n     */\n    async finalText() {\n        await this.done();\n        return __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_getFinalText).call(this);\n    }\n    _emit(event, ...args) {\n        // make sure we don't emit any MessageStreamEvents after end\n        if (__classPrivateFieldGet(this, _MessageStream_ended, \"f\"))\n            return;\n        if (event === 'end') {\n            __classPrivateFieldSet(this, _MessageStream_ended, true, \"f\");\n            __classPrivateFieldGet(this, _MessageStream_resolveEndPromise, \"f\").call(this);\n        }\n        const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event];\n        if (listeners) {\n            __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] = listeners.filter((l) => !l.once);\n            listeners.forEach(({ listener }) => listener(...args));\n        }\n        if (event === 'abort') {\n            const error = args[0];\n            if (!__classPrivateFieldGet(this, _MessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                Promise.reject(error);\n            }\n            __classPrivateFieldGet(this, _MessageStream_rejectConnectedPromise, \"f\").call(this, error);\n            __classPrivateFieldGet(this, _MessageStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n            return;\n        }\n        if (event === 'error') {\n            // NOTE: _emit('error', error) should only be called from #handleError().\n            const error = args[0];\n            if (!__classPrivateFieldGet(this, _MessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n                // If you are seeing stack traces here, make sure to handle errors via either:\n                // - runner.on('error', () => ...)\n                // - await runner.done()\n                // - await runner.final...()\n                // - etc.\n                Promise.reject(error);\n            }\n            __classPrivateFieldGet(this, _MessageStream_rejectConnectedPromise, \"f\").call(this, error);\n            __classPrivateFieldGet(this, _MessageStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n        }\n    }\n    _emitFinal() {\n        const finalMessage = this.receivedMessages.at(-1);\n        if (finalMessage) {\n            this._emit('finalMessage', __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_getFinalMessage).call(this));\n        }\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_beginRequest).call(this);\n        this._connected(null);\n        const stream = Stream.fromReadableStream(readableStream, this.controller);\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_addStreamEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_endRequest).call(this);\n    }\n    [(_MessageStream_currentMessageSnapshot = new WeakMap(), _MessageStream_connectedPromise = new WeakMap(), _MessageStream_resolveConnectedPromise = new WeakMap(), _MessageStream_rejectConnectedPromise = new WeakMap(), _MessageStream_endPromise = new WeakMap(), _MessageStream_resolveEndPromise = new WeakMap(), _MessageStream_rejectEndPromise = new WeakMap(), _MessageStream_listeners = new WeakMap(), _MessageStream_ended = new WeakMap(), _MessageStream_errored = new WeakMap(), _MessageStream_aborted = new WeakMap(), _MessageStream_catchingPromiseCreated = new WeakMap(), _MessageStream_response = new WeakMap(), _MessageStream_request_id = new WeakMap(), _MessageStream_handleError = new WeakMap(), _MessageStream_instances = new WeakSet(), _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage() {\n        if (this.receivedMessages.length === 0) {\n            throw new AnthropicError('stream ended without producing a Message with role=assistant');\n        }\n        return this.receivedMessages.at(-1);\n    }, _MessageStream_getFinalText = function _MessageStream_getFinalText() {\n        if (this.receivedMessages.length === 0) {\n            throw new AnthropicError('stream ended without producing a Message with role=assistant');\n        }\n        const textBlocks = this.receivedMessages\n            .at(-1)\n            .content.filter((block) => block.type === 'text')\n            .map((block) => block.text);\n        if (textBlocks.length === 0) {\n            throw new AnthropicError('stream ended without producing a content block with type=text');\n        }\n        return textBlocks.join(' ');\n    }, _MessageStream_beginRequest = function _MessageStream_beginRequest() {\n        if (this.ended)\n            return;\n        __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, undefined, \"f\");\n    }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent(event) {\n        if (this.ended)\n            return;\n        const messageSnapshot = __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_accumulateMessage).call(this, event);\n        this._emit('streamEvent', event, messageSnapshot);\n        switch (event.type) {\n            case 'content_block_delta': {\n                const content = messageSnapshot.content.at(-1);\n                switch (event.delta.type) {\n                    case 'text_delta': {\n                        if (content.type === 'text') {\n                            this._emit('text', event.delta.text, content.text || '');\n                        }\n                        break;\n                    }\n                    case 'citations_delta': {\n                        if (content.type === 'text') {\n                            this._emit('citation', event.delta.citation, content.citations ?? []);\n                        }\n                        break;\n                    }\n                    case 'input_json_delta': {\n                        if (tracksToolInput(content) && content.input) {\n                            this._emit('inputJson', event.delta.partial_json, content.input);\n                        }\n                        break;\n                    }\n                    case 'thinking_delta': {\n                        if (content.type === 'thinking') {\n                            this._emit('thinking', event.delta.thinking, content.thinking);\n                        }\n                        break;\n                    }\n                    case 'signature_delta': {\n                        if (content.type === 'thinking') {\n                            this._emit('signature', content.signature);\n                        }\n                        break;\n                    }\n                    default:\n                        checkNever(event.delta);\n                }\n                break;\n            }\n            case 'message_stop': {\n                this._addMessageParam(messageSnapshot);\n                this._addMessage(messageSnapshot, true);\n                break;\n            }\n            case 'content_block_stop': {\n                this._emit('contentBlock', messageSnapshot.content.at(-1));\n                break;\n            }\n            case 'message_start': {\n                __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, messageSnapshot, \"f\");\n                break;\n            }\n            case 'content_block_start':\n            case 'message_delta':\n                break;\n        }\n    }, _MessageStream_endRequest = function _MessageStream_endRequest() {\n        if (this.ended) {\n            throw new AnthropicError(`stream has ended, this shouldn't happen`);\n        }\n        const snapshot = __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, \"f\");\n        if (!snapshot) {\n            throw new AnthropicError(`request ended without sending any chunks`);\n        }\n        __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, undefined, \"f\");\n        return snapshot;\n    }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage(event) {\n        let snapshot = __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, \"f\");\n        if (event.type === 'message_start') {\n            if (snapshot) {\n                throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\n            }\n            return event.message;\n        }\n        if (!snapshot) {\n            throw new AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\n        }\n        switch (event.type) {\n            case 'message_stop':\n                return snapshot;\n            case 'message_delta':\n                snapshot.stop_reason = event.delta.stop_reason;\n                snapshot.stop_sequence = event.delta.stop_sequence;\n                snapshot.usage.output_tokens = event.usage.output_tokens;\n                // Update other usage fields if they exist in the event\n                if (event.usage.input_tokens != null) {\n                    snapshot.usage.input_tokens = event.usage.input_tokens;\n                }\n                if (event.usage.cache_creation_input_tokens != null) {\n                    snapshot.usage.cache_creation_input_tokens = event.usage.cache_creation_input_tokens;\n                }\n                if (event.usage.cache_read_input_tokens != null) {\n                    snapshot.usage.cache_read_input_tokens = event.usage.cache_read_input_tokens;\n                }\n                if (event.usage.server_tool_use != null) {\n                    snapshot.usage.server_tool_use = event.usage.server_tool_use;\n                }\n                return snapshot;\n            case 'content_block_start':\n                snapshot.content.push(event.content_block);\n                return snapshot;\n            case 'content_block_delta': {\n                const snapshotContent = snapshot.content.at(event.index);\n                switch (event.delta.type) {\n                    case 'text_delta': {\n                        if (snapshotContent?.type === 'text') {\n                            snapshotContent.text += event.delta.text;\n                        }\n                        break;\n                    }\n                    case 'citations_delta': {\n                        if (snapshotContent?.type === 'text') {\n                            snapshotContent.citations ?? (snapshotContent.citations = []);\n                            snapshotContent.citations.push(event.delta.citation);\n                        }\n                        break;\n                    }\n                    case 'input_json_delta': {\n                        if (snapshotContent && tracksToolInput(snapshotContent)) {\n                            // we need to keep track of the raw JSON string as well so that we can\n                            // re-parse it for each delta, for now we just store it as an untyped\n                            // non-enumerable property on the snapshot\n                            let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || '';\n                            jsonBuf += event.delta.partial_json;\n                            Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {\n                                value: jsonBuf,\n                                enumerable: false,\n                                writable: true,\n                            });\n                            if (jsonBuf) {\n                                snapshotContent.input = partialParse(jsonBuf);\n                            }\n                        }\n                        break;\n                    }\n                    case 'thinking_delta': {\n                        if (snapshotContent?.type === 'thinking') {\n                            snapshotContent.thinking += event.delta.thinking;\n                        }\n                        break;\n                    }\n                    case 'signature_delta': {\n                        if (snapshotContent?.type === 'thinking') {\n                            snapshotContent.signature = event.delta.signature;\n                        }\n                        break;\n                    }\n                    default:\n                        checkNever(event.delta);\n                }\n                return snapshot;\n            }\n            case 'content_block_stop':\n                return snapshot;\n        }\n    }, Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        this.on('streamEvent', (event) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(event);\n            }\n            else {\n                pushQueue.push(event);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                }\n                const chunk = pushQueue.shift();\n                return { value: chunk, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    toReadableStream() {\n        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n}\n// used to ensure exhaustive case matching without throwing a runtime error\nfunction checkNever(x) { }\n//# sourceMappingURL=MessageStream.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../core/resource.mjs\";\nimport { Page } from \"../../core/pagination.mjs\";\nimport { buildHeaders } from \"../../internal/headers.mjs\";\nimport { JSONLDecoder } from \"../../internal/decoders/jsonl.mjs\";\nimport { AnthropicError } from \"../../error.mjs\";\nimport { path } from \"../../internal/utils/path.mjs\";\nexport class Batches extends APIResource {\n    /**\n     * Send a batch of Message creation requests.\n     *\n     * The Message Batches API can be used to process multiple Messages API requests at\n     * once. Once a Message Batch is created, it begins processing immediately. Batches\n     * can take up to 24 hours to complete.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const messageBatch = await client.messages.batches.create({\n     *   requests: [\n     *     {\n     *       custom_id: 'my-custom-id-1',\n     *       params: {\n     *         max_tokens: 1024,\n     *         messages: [\n     *           { content: 'Hello, world', role: 'user' },\n     *         ],\n     *         model: 'claude-3-7-sonnet-20250219',\n     *       },\n     *     },\n     *   ],\n     * });\n     * ```\n     */\n    create(body, options) {\n        return this._client.post('/v1/messages/batches', { body, ...options });\n    }\n    /**\n     * This endpoint is idempotent and can be used to poll for Message Batch\n     * completion. To access the results of a Message Batch, make a request to the\n     * `results_url` field in the response.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const messageBatch = await client.messages.batches.retrieve(\n     *   'message_batch_id',\n     * );\n     * ```\n     */\n    retrieve(messageBatchID, options) {\n        return this._client.get(path `/v1/messages/batches/${messageBatchID}`, options);\n    }\n    /**\n     * List all Message Batches within a Workspace. Most recently created batches are\n     * returned first.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * // Automatically fetches more pages as needed.\n     * for await (const messageBatch of client.messages.batches.list()) {\n     *   // ...\n     * }\n     * ```\n     */\n    list(query = {}, options) {\n        return this._client.getAPIList('/v1/messages/batches', (Page), { query, ...options });\n    }\n    /**\n     * Delete a Message Batch.\n     *\n     * Message Batches can only be deleted once they've finished processing. If you'd\n     * like to delete an in-progress batch, you must first cancel it.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const deletedMessageBatch =\n     *   await client.messages.batches.delete('message_batch_id');\n     * ```\n     */\n    delete(messageBatchID, options) {\n        return this._client.delete(path `/v1/messages/batches/${messageBatchID}`, options);\n    }\n    /**\n     * Batches may be canceled any time before processing ends. Once cancellation is\n     * initiated, the batch enters a `canceling` state, at which time the system may\n     * complete any in-progress, non-interruptible requests before finalizing\n     * cancellation.\n     *\n     * The number of canceled requests is specified in `request_counts`. To determine\n     * which requests were canceled, check the individual results within the batch.\n     * Note that cancellation may not result in any canceled requests if they were\n     * non-interruptible.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const messageBatch = await client.messages.batches.cancel(\n     *   'message_batch_id',\n     * );\n     * ```\n     */\n    cancel(messageBatchID, options) {\n        return this._client.post(path `/v1/messages/batches/${messageBatchID}/cancel`, options);\n    }\n    /**\n     * Streams the results of a Message Batch as a `.jsonl` file.\n     *\n     * Each line in the file is a JSON object containing the result of a single request\n     * in the Message Batch. Results are not guaranteed to be in the same order as\n     * requests. Use the `custom_id` field to match results to requests.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const messageBatchIndividualResponse =\n     *   await client.messages.batches.results('message_batch_id');\n     * ```\n     */\n    async results(messageBatchID, options) {\n        const batch = await this.retrieve(messageBatchID);\n        if (!batch.results_url) {\n            throw new AnthropicError(`No batch \\`results_url\\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);\n        }\n        return this._client\n            .get(batch.results_url, {\n            ...options,\n            headers: buildHeaders([{ Accept: 'application/binary' }, options?.headers]),\n            stream: true,\n            __binaryResponse: true,\n        })\n            ._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));\n    }\n}\n//# sourceMappingURL=batches.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../core/resource.mjs\";\nimport { MessageStream } from \"../../lib/MessageStream.mjs\";\nimport * as BatchesAPI from \"./batches.mjs\";\nimport { Batches, } from \"./batches.mjs\";\nimport { MODEL_NONSTREAMING_TOKENS } from \"../../internal/constants.mjs\";\nexport class Messages extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.batches = new BatchesAPI.Batches(this._client);\n    }\n    create(body, options) {\n        if (body.model in DEPRECATED_MODELS) {\n            console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}\\nPlease migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);\n        }\n        let timeout = this._client._options.timeout;\n        if (!body.stream && timeout == null) {\n            const maxNonstreamingTokens = MODEL_NONSTREAMING_TOKENS[body.model] ?? undefined;\n            timeout = this._client.calculateNonstreamingTimeout(body.max_tokens, maxNonstreamingTokens);\n        }\n        return this._client.post('/v1/messages', {\n            body,\n            timeout: timeout ?? 600000,\n            ...options,\n            stream: body.stream ?? false,\n        });\n    }\n    /**\n     * Create a Message stream\n     */\n    stream(body, options) {\n        return MessageStream.createMessage(this, body, options);\n    }\n    /**\n     * Count the number of tokens in a Message.\n     *\n     * The Token Count API can be used to count the number of tokens in a Message,\n     * including tools, images, and documents, without creating it.\n     *\n     * Learn more about token counting in our\n     * [user guide](/en/docs/build-with-claude/token-counting)\n     *\n     * @example\n     * ```ts\n     * const messageTokensCount =\n     *   await client.messages.countTokens({\n     *     messages: [{ content: 'string', role: 'user' }],\n     *     model: 'claude-3-7-sonnet-latest',\n     *   });\n     * ```\n     */\n    countTokens(body, options) {\n        return this._client.post('/v1/messages/count_tokens', { body, ...options });\n    }\n}\nconst DEPRECATED_MODELS = {\n    'claude-1.3': 'November 6th, 2024',\n    'claude-1.3-100k': 'November 6th, 2024',\n    'claude-instant-1.1': 'November 6th, 2024',\n    'claude-instant-1.1-100k': 'November 6th, 2024',\n    'claude-instant-1.2': 'November 6th, 2024',\n    'claude-3-sonnet-20240229': 'July 21st, 2025',\n    'claude-2.1': 'July 21st, 2025',\n    'claude-2.0': 'July 21st, 2025',\n};\nMessages.Batches = Batches;\n//# sourceMappingURL=messages.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../core/resource.mjs\";\nimport { Page } from \"../core/pagination.mjs\";\nimport { buildHeaders } from \"../internal/headers.mjs\";\nimport { path } from \"../internal/utils/path.mjs\";\nexport class Models extends APIResource {\n    /**\n     * Get a specific model.\n     *\n     * The Models API response can be used to determine information about a specific\n     * model or resolve a model alias to a model ID.\n     */\n    retrieve(modelID, params = {}, options) {\n        const { betas } = params ?? {};\n        return this._client.get(path `/v1/models/${modelID}`, {\n            ...options,\n            headers: buildHeaders([\n                { ...(betas?.toString() != null ? { 'anthropic-beta': betas?.toString() } : undefined) },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * List available models.\n     *\n     * The Models API response can be used to determine which models are available for\n     * use in the API. More recently released models are listed first.\n     */\n    list(params = {}, options) {\n        const { betas, ...query } = params ?? {};\n        return this._client.getAPIList('/v1/models', (Page), {\n            query,\n            ...options,\n            headers: buildHeaders([\n                { ...(betas?.toString() != null ? { 'anthropic-beta': betas?.toString() } : undefined) },\n                options?.headers,\n            ]),\n        });\n    }\n}\n//# sourceMappingURL=models.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n/**\n * Read an environment variable.\n *\n * Trims beginning and trailing whitespace.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */\nexport const readEnv = (env) => {\n    if (typeof globalThis.process !== 'undefined') {\n        return globalThis.process.env?.[env]?.trim() ?? undefined;\n    }\n    if (typeof globalThis.Deno !== 'undefined') {\n        return globalThis.Deno.env?.get?.(env)?.trim();\n    }\n    return undefined;\n};\n//# sourceMappingURL=env.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar _a, _BaseAnthropic_encoder;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"./internal/tslib.mjs\";\nimport { uuid4 } from \"./internal/utils/uuid.mjs\";\nimport { validatePositiveInteger, isAbsoluteURL, safeJSON } from \"./internal/utils/values.mjs\";\nimport { sleep } from \"./internal/utils/sleep.mjs\";\nimport { parseLogLevel } from \"./internal/utils/log.mjs\";\nimport { castToError, isAbortError } from \"./internal/errors.mjs\";\nimport { getPlatformHeaders } from \"./internal/detect-platform.mjs\";\nimport * as Shims from \"./internal/shims.mjs\";\nimport * as Opts from \"./internal/request-options.mjs\";\nimport { VERSION } from \"./version.mjs\";\nimport * as Errors from \"./core/error.mjs\";\nimport * as Pagination from \"./core/pagination.mjs\";\nimport * as Uploads from \"./core/uploads.mjs\";\nimport * as API from \"./resources/index.mjs\";\nimport { APIPromise } from \"./core/api-promise.mjs\";\nimport { isRunningInBrowser } from \"./internal/detect-platform.mjs\";\nimport { buildHeaders } from \"./internal/headers.mjs\";\nimport { Completions, } from \"./resources/completions.mjs\";\nimport { Models } from \"./resources/models.mjs\";\nimport { readEnv } from \"./internal/utils/env.mjs\";\nimport { formatRequestDetails, loggerFor } from \"./internal/utils/log.mjs\";\nimport { isEmptyObj } from \"./internal/utils/values.mjs\";\nimport { Beta, } from \"./resources/beta/beta.mjs\";\nimport { Messages, } from \"./resources/messages/messages.mjs\";\nexport class BaseAnthropic {\n    /**\n     * API Client for interfacing with the Anthropic API.\n     *\n     * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]\n     * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]\n     * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.\n     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n     * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.\n     * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n     * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.\n     * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.\n     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n     */\n    constructor({ baseURL = readEnv('ANTHROPIC_BASE_URL'), apiKey = readEnv('ANTHROPIC_API_KEY') ?? null, authToken = readEnv('ANTHROPIC_AUTH_TOKEN') ?? null, ...opts } = {}) {\n        _BaseAnthropic_encoder.set(this, void 0);\n        const options = {\n            apiKey,\n            authToken,\n            ...opts,\n            baseURL: baseURL || `https://api.anthropic.com`,\n        };\n        if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {\n            throw new Errors.AnthropicError(\"It looks like you're running in a browser-like environment.\\n\\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\\nIf you understand the risks and have appropriate mitigations in place,\\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\\n\\nnew Anthropic({ apiKey, dangerouslyAllowBrowser: true });\\n\");\n        }\n        this.baseURL = options.baseURL;\n        this.timeout = options.timeout ?? Anthropic.DEFAULT_TIMEOUT /* 10 minutes */;\n        this.logger = options.logger ?? console;\n        const defaultLogLevel = 'warn';\n        // Set default logLevel early so that we can log a warning in parseLogLevel.\n        this.logLevel = defaultLogLevel;\n        this.logLevel =\n            parseLogLevel(options.logLevel, 'ClientOptions.logLevel', this) ??\n                parseLogLevel(readEnv('ANTHROPIC_LOG'), \"process.env['ANTHROPIC_LOG']\", this) ??\n                defaultLogLevel;\n        this.fetchOptions = options.fetchOptions;\n        this.maxRetries = options.maxRetries ?? 2;\n        this.fetch = options.fetch ?? Shims.getDefaultFetch();\n        __classPrivateFieldSet(this, _BaseAnthropic_encoder, Opts.FallbackEncoder, \"f\");\n        this._options = options;\n        this.apiKey = apiKey;\n        this.authToken = authToken;\n    }\n    /**\n     * Create a new client instance re-using the same options given to the current client with optional overriding.\n     */\n    withOptions(options) {\n        return new this.constructor({\n            ...this._options,\n            baseURL: this.baseURL,\n            maxRetries: this.maxRetries,\n            timeout: this.timeout,\n            logger: this.logger,\n            logLevel: this.logLevel,\n            fetchOptions: this.fetchOptions,\n            apiKey: this.apiKey,\n            authToken: this.authToken,\n            ...options,\n        });\n    }\n    defaultQuery() {\n        return this._options.defaultQuery;\n    }\n    validateHeaders({ values, nulls }) {\n        if (this.apiKey && values.get('x-api-key')) {\n            return;\n        }\n        if (nulls.has('x-api-key')) {\n            return;\n        }\n        if (this.authToken && values.get('authorization')) {\n            return;\n        }\n        if (nulls.has('authorization')) {\n            return;\n        }\n        throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the \"X-Api-Key\" or \"Authorization\" headers to be explicitly omitted');\n    }\n    authHeaders(opts) {\n        return buildHeaders([this.apiKeyAuth(opts), this.bearerAuth(opts)]);\n    }\n    apiKeyAuth(opts) {\n        if (this.apiKey == null) {\n            return undefined;\n        }\n        return buildHeaders([{ 'X-Api-Key': this.apiKey }]);\n    }\n    bearerAuth(opts) {\n        if (this.authToken == null) {\n            return undefined;\n        }\n        return buildHeaders([{ Authorization: `Bearer ${this.authToken}` }]);\n    }\n    /**\n     * Basic re-implementation of `qs.stringify` for primitive types.\n     */\n    stringifyQuery(query) {\n        return Object.entries(query)\n            .filter(([_, value]) => typeof value !== 'undefined')\n            .map(([key, value]) => {\n            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n                return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n            }\n            if (value === null) {\n                return `${encodeURIComponent(key)}=`;\n            }\n            throw new Errors.AnthropicError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);\n        })\n            .join('&');\n    }\n    getUserAgent() {\n        return `${this.constructor.name}/JS ${VERSION}`;\n    }\n    defaultIdempotencyKey() {\n        return `stainless-node-retry-${uuid4()}`;\n    }\n    makeStatusError(status, error, message, headers) {\n        return Errors.APIError.generate(status, error, message, headers);\n    }\n    buildURL(path, query) {\n        const url = isAbsoluteURL(path) ?\n            new URL(path)\n            : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n        const defaultQuery = this.defaultQuery();\n        if (!isEmptyObj(defaultQuery)) {\n            query = { ...defaultQuery, ...query };\n        }\n        if (typeof query === 'object' && query && !Array.isArray(query)) {\n            url.search = this.stringifyQuery(query);\n        }\n        return url.toString();\n    }\n    _calculateNonstreamingTimeout(maxTokens) {\n        const defaultTimeout = 10 * 60;\n        const expectedTimeout = (60 * 60 * maxTokens) / 128000;\n        if (expectedTimeout > defaultTimeout) {\n            throw new Errors.AnthropicError('Streaming is strongly recommended for operations that may take longer than 10 minutes. ' +\n                'See https://github.com/anthropics/anthropic-sdk-typescript#streaming-responses for more details');\n        }\n        return defaultTimeout * 1000;\n    }\n    /**\n     * Used as a callback for mutating the given `FinalRequestOptions` object.\n     */\n    async prepareOptions(options) { }\n    /**\n     * Used as a callback for mutating the given `RequestInit` object.\n     *\n     * This is useful for cases where you want to add certain headers based off of\n     * the request properties, e.g. `method` or `url`.\n     */\n    async prepareRequest(request, { url, options }) { }\n    get(path, opts) {\n        return this.methodRequest('get', path, opts);\n    }\n    post(path, opts) {\n        return this.methodRequest('post', path, opts);\n    }\n    patch(path, opts) {\n        return this.methodRequest('patch', path, opts);\n    }\n    put(path, opts) {\n        return this.methodRequest('put', path, opts);\n    }\n    delete(path, opts) {\n        return this.methodRequest('delete', path, opts);\n    }\n    methodRequest(method, path, opts) {\n        return this.request(Promise.resolve(opts).then((opts) => {\n            return { method, path, ...opts };\n        }));\n    }\n    request(options, remainingRetries = null) {\n        return new APIPromise(this, this.makeRequest(options, remainingRetries, undefined));\n    }\n    async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {\n        const options = await optionsInput;\n        const maxRetries = options.maxRetries ?? this.maxRetries;\n        if (retriesRemaining == null) {\n            retriesRemaining = maxRetries;\n        }\n        await this.prepareOptions(options);\n        const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });\n        await this.prepareRequest(req, { url, options });\n        /** Not an API request ID, just for correlating local log entries. */\n        const requestLogID = 'log_' + ((Math.random() * (1 << 24)) | 0).toString(16).padStart(6, '0');\n        const retryLogStr = retryOfRequestLogID === undefined ? '' : `, retryOf: ${retryOfRequestLogID}`;\n        const startTime = Date.now();\n        loggerFor(this).debug(`[${requestLogID}] sending request`, formatRequestDetails({\n            retryOfRequestLogID,\n            method: options.method,\n            url,\n            options,\n            headers: req.headers,\n        }));\n        if (options.signal?.aborted) {\n            throw new Errors.APIUserAbortError();\n        }\n        const controller = new AbortController();\n        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\n        const headersTime = Date.now();\n        if (response instanceof Error) {\n            const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n            if (options.signal?.aborted) {\n                throw new Errors.APIUserAbortError();\n            }\n            // detect native connection timeout errors\n            // deno throws \"TypeError: error sending request for url (https://example/): client error (Connect): tcp connect error: Operation timed out (os error 60): Operation timed out (os error 60)\"\n            // undici throws \"TypeError: fetch failed\" with cause \"ConnectTimeoutError: Connect Timeout Error (attempted address: example:443, timeout: 1ms)\"\n            // others do not provide enough information to distinguish timeouts from other connection errors\n            const isTimeout = isAbortError(response) ||\n                /timed? ?out/i.test(String(response) + ('cause' in response ? String(response.cause) : ''));\n            if (retriesRemaining) {\n                loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} - ${retryMessage}`);\n                loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} (${retryMessage})`, formatRequestDetails({\n                    retryOfRequestLogID,\n                    url,\n                    durationMs: headersTime - startTime,\n                    message: response.message,\n                }));\n                return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);\n            }\n            loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} - error; no more retries left`);\n            loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} (error; no more retries left)`, formatRequestDetails({\n                retryOfRequestLogID,\n                url,\n                durationMs: headersTime - startTime,\n                message: response.message,\n            }));\n            if (isTimeout) {\n                throw new Errors.APIConnectionTimeoutError();\n            }\n            throw new Errors.APIConnectionError({ cause: response });\n        }\n        const specialHeaders = [...response.headers.entries()]\n            .filter(([name]) => name === 'request-id')\n            .map(([name, value]) => ', ' + name + ': ' + JSON.stringify(value))\n            .join('');\n        const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req.method} ${url} ${response.ok ? 'succeeded' : 'failed'} with status ${response.status} in ${headersTime - startTime}ms`;\n        if (!response.ok) {\n            const shouldRetry = this.shouldRetry(response);\n            if (retriesRemaining && shouldRetry) {\n                const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n                // We don't need the body of this response.\n                await Shims.CancelReadableStream(response.body);\n                loggerFor(this).info(`${responseInfo} - ${retryMessage}`);\n                loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({\n                    retryOfRequestLogID,\n                    url: response.url,\n                    status: response.status,\n                    headers: response.headers,\n                    durationMs: headersTime - startTime,\n                }));\n                return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);\n            }\n            const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;\n            loggerFor(this).info(`${responseInfo} - ${retryMessage}`);\n            const errText = await response.text().catch((err) => castToError(err).message);\n            const errJSON = safeJSON(errText);\n            const errMessage = errJSON ? undefined : errText;\n            loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({\n                retryOfRequestLogID,\n                url: response.url,\n                status: response.status,\n                headers: response.headers,\n                message: errMessage,\n                durationMs: Date.now() - startTime,\n            }));\n            const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);\n            throw err;\n        }\n        loggerFor(this).info(responseInfo);\n        loggerFor(this).debug(`[${requestLogID}] response start`, formatRequestDetails({\n            retryOfRequestLogID,\n            url: response.url,\n            status: response.status,\n            headers: response.headers,\n            durationMs: headersTime - startTime,\n        }));\n        return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };\n    }\n    getAPIList(path, Page, opts) {\n        return this.requestAPIList(Page, { method: 'get', path, ...opts });\n    }\n    requestAPIList(Page, options) {\n        const request = this.makeRequest(options, null, undefined);\n        return new Pagination.PagePromise(this, request, Page);\n    }\n    async fetchWithTimeout(url, init, ms, controller) {\n        const { signal, method, ...options } = init || {};\n        if (signal)\n            signal.addEventListener('abort', () => controller.abort());\n        const timeout = setTimeout(() => controller.abort(), ms);\n        const isReadableBody = (globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream) ||\n            (typeof options.body === 'object' && options.body !== null && Symbol.asyncIterator in options.body);\n        const fetchOptions = {\n            signal: controller.signal,\n            ...(isReadableBody ? { duplex: 'half' } : {}),\n            method: 'GET',\n            ...options,\n        };\n        if (method) {\n            // Custom methods like 'patch' need to be uppercased\n            // See https://github.com/nodejs/undici/issues/2294\n            fetchOptions.method = method.toUpperCase();\n        }\n        try {\n            // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n            return await this.fetch.call(undefined, url, fetchOptions);\n        }\n        finally {\n            clearTimeout(timeout);\n        }\n    }\n    shouldRetry(response) {\n        // Note this is not a standard header.\n        const shouldRetryHeader = response.headers.get('x-should-retry');\n        // If the server explicitly says whether or not to retry, obey.\n        if (shouldRetryHeader === 'true')\n            return true;\n        if (shouldRetryHeader === 'false')\n            return false;\n        // Retry on request timeouts.\n        if (response.status === 408)\n            return true;\n        // Retry on lock timeouts.\n        if (response.status === 409)\n            return true;\n        // Retry on rate limits.\n        if (response.status === 429)\n            return true;\n        // Retry internal errors.\n        if (response.status >= 500)\n            return true;\n        return false;\n    }\n    async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {\n        let timeoutMillis;\n        // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\n        const retryAfterMillisHeader = responseHeaders?.get('retry-after-ms');\n        if (retryAfterMillisHeader) {\n            const timeoutMs = parseFloat(retryAfterMillisHeader);\n            if (!Number.isNaN(timeoutMs)) {\n                timeoutMillis = timeoutMs;\n            }\n        }\n        // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n        const retryAfterHeader = responseHeaders?.get('retry-after');\n        if (retryAfterHeader && !timeoutMillis) {\n            const timeoutSeconds = parseFloat(retryAfterHeader);\n            if (!Number.isNaN(timeoutSeconds)) {\n                timeoutMillis = timeoutSeconds * 1000;\n            }\n            else {\n                timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n            }\n        }\n        // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n        // just do what it says, but otherwise calculate a default\n        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\n            const maxRetries = options.maxRetries ?? this.maxRetries;\n            timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n        }\n        await sleep(timeoutMillis);\n        return this.makeRequest(options, retriesRemaining - 1, requestLogID);\n    }\n    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {\n        const initialRetryDelay = 0.5;\n        const maxRetryDelay = 8.0;\n        const numRetries = maxRetries - retriesRemaining;\n        // Apply exponential backoff, but not more than the max.\n        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\n        // Apply some jitter, take up to at most 25 percent of the retry time.\n        const jitter = 1 - Math.random() * 0.25;\n        return sleepSeconds * jitter * 1000;\n    }\n    calculateNonstreamingTimeout(maxTokens, maxNonstreamingTokens) {\n        const maxTime = 60 * 60 * 1000; // 10 minutes\n        const defaultTime = 60 * 10 * 1000; // 10 minutes\n        const expectedTime = (maxTime * maxTokens) / 128000;\n        if (expectedTime > defaultTime || (maxNonstreamingTokens != null && maxTokens > maxNonstreamingTokens)) {\n            throw new Errors.AnthropicError('Streaming is strongly recommended for operations that may token longer than 10 minutes. See https://github.com/anthropics/anthropic-sdk-typescript#long-requests for more details');\n        }\n        return defaultTime;\n    }\n    buildRequest(inputOptions, { retryCount = 0 } = {}) {\n        const options = { ...inputOptions };\n        const { method, path, query } = options;\n        const url = this.buildURL(path, query);\n        if ('timeout' in options)\n            validatePositiveInteger('timeout', options.timeout);\n        options.timeout = options.timeout ?? this.timeout;\n        const { bodyHeaders, body } = this.buildBody({ options });\n        const reqHeaders = this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });\n        const req = {\n            method,\n            headers: reqHeaders,\n            ...(options.signal && { signal: options.signal }),\n            ...(globalThis.ReadableStream &&\n                body instanceof globalThis.ReadableStream && { duplex: 'half' }),\n            ...(body && { body }),\n            ...(this.fetchOptions ?? {}),\n            ...(options.fetchOptions ?? {}),\n        };\n        return { req, url, timeout: options.timeout };\n    }\n    buildHeaders({ options, method, bodyHeaders, retryCount, }) {\n        let idempotencyHeaders = {};\n        if (this.idempotencyHeader && method !== 'get') {\n            if (!options.idempotencyKey)\n                options.idempotencyKey = this.defaultIdempotencyKey();\n            idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;\n        }\n        const headers = buildHeaders([\n            idempotencyHeaders,\n            {\n                Accept: 'application/json',\n                'User-Agent': this.getUserAgent(),\n                'X-Stainless-Retry-Count': String(retryCount),\n                ...(options.timeout ? { 'X-Stainless-Timeout': String(Math.trunc(options.timeout / 1000)) } : {}),\n                ...getPlatformHeaders(),\n                ...(this._options.dangerouslyAllowBrowser ?\n                    { 'anthropic-dangerous-direct-browser-access': 'true' }\n                    : undefined),\n                'anthropic-version': '2023-06-01',\n            },\n            this.authHeaders(options),\n            this._options.defaultHeaders,\n            bodyHeaders,\n            options.headers,\n        ]);\n        this.validateHeaders(headers);\n        return headers.values;\n    }\n    buildBody({ options: { body, headers: rawHeaders } }) {\n        if (!body) {\n            return { bodyHeaders: undefined, body: undefined };\n        }\n        const headers = buildHeaders([rawHeaders]);\n        if (\n        // Pass raw type verbatim\n        ArrayBuffer.isView(body) ||\n            body instanceof ArrayBuffer ||\n            body instanceof DataView ||\n            (typeof body === 'string' &&\n                // Preserve legacy string encoding behavior for now\n                headers.values.has('content-type')) ||\n            // `Blob` is superset of `File`\n            body instanceof Blob ||\n            // `FormData` -> `multipart/form-data`\n            body instanceof FormData ||\n            // `URLSearchParams` -> `application/x-www-form-urlencoded`\n            body instanceof URLSearchParams ||\n            // Send chunked stream (each chunk has own `length`)\n            (globalThis.ReadableStream && body instanceof globalThis.ReadableStream)) {\n            return { bodyHeaders: undefined, body: body };\n        }\n        else if (typeof body === 'object' &&\n            (Symbol.asyncIterator in body ||\n                (Symbol.iterator in body && 'next' in body && typeof body.next === 'function'))) {\n            return { bodyHeaders: undefined, body: Shims.ReadableStreamFrom(body) };\n        }\n        else {\n            return __classPrivateFieldGet(this, _BaseAnthropic_encoder, \"f\").call(this, { body, headers });\n        }\n    }\n}\n_a = BaseAnthropic, _BaseAnthropic_encoder = new WeakMap();\nBaseAnthropic.Anthropic = _a;\nBaseAnthropic.HUMAN_PROMPT = '\\n\\nHuman:';\nBaseAnthropic.AI_PROMPT = '\\n\\nAssistant:';\nBaseAnthropic.DEFAULT_TIMEOUT = 600000; // 10 minutes\nBaseAnthropic.AnthropicError = Errors.AnthropicError;\nBaseAnthropic.APIError = Errors.APIError;\nBaseAnthropic.APIConnectionError = Errors.APIConnectionError;\nBaseAnthropic.APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;\nBaseAnthropic.APIUserAbortError = Errors.APIUserAbortError;\nBaseAnthropic.NotFoundError = Errors.NotFoundError;\nBaseAnthropic.ConflictError = Errors.ConflictError;\nBaseAnthropic.RateLimitError = Errors.RateLimitError;\nBaseAnthropic.BadRequestError = Errors.BadRequestError;\nBaseAnthropic.AuthenticationError = Errors.AuthenticationError;\nBaseAnthropic.InternalServerError = Errors.InternalServerError;\nBaseAnthropic.PermissionDeniedError = Errors.PermissionDeniedError;\nBaseAnthropic.UnprocessableEntityError = Errors.UnprocessableEntityError;\nBaseAnthropic.toFile = Uploads.toFile;\n/**\n * API Client for interfacing with the Anthropic API.\n */\nexport class Anthropic extends BaseAnthropic {\n    constructor() {\n        super(...arguments);\n        this.completions = new API.Completions(this);\n        this.messages = new API.Messages(this);\n        this.models = new API.Models(this);\n        this.beta = new API.Beta(this);\n    }\n}\nAnthropic.Completions = Completions;\nAnthropic.Messages = Messages;\nAnthropic.Models = Models;\nAnthropic.Beta = Beta;\nexport const { HUMAN_PROMPT, AI_PROMPT } = Anthropic;\n//# sourceMappingURL=client.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nexport const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n//# sourceMappingURL=sleep.mjs.map"],"names":["__classPrivateFieldSet","receiver","state","value","kind","f","TypeError","has","call","set","__classPrivateFieldGet","get","uuid4","crypto","globalThis","randomUUID","bind","u8","Uint8Array","randomByte","getRandomValues","Math","random","replace","c","toString","isAbortError","err","name","String","message","includes","castToError","Error","Object","prototype","error","cause","stack","JSON","stringify","APIError","constructor","status","headers","super","makeMessage","this","requestID","msg","generate","errorResponse","APIConnectionError","BadRequestError","AuthenticationError","PermissionDeniedError","NotFoundError","ConflictError","UnprocessableEntityError","RateLimitError","InternalServerError","APIUserAbortError","undefined","APIConnectionTimeoutError","startsWithSchemeRegexp","maybeObj","x","safeJSON","text","parse","levelNumbers","off","warn","info","debug","parseLogLevel","maybeLevel","sourceName","client","obj","key","hasOwnProperty","loggerFor","keys","noop","makeLogFn","fnLevel","logger","logLevel","noopLogger","cachedLoggers","WeakMap","cachedLogger","levelLogger","formatRequestDetails","details","options","fromEntries","Headers","entries","map","toLowerCase","retryOfRequestLogID","retryOf","VERSION","getPlatformProperties","detectedPlatform","Deno","build","EdgeRuntime","process","normalizePlatform","os","normalizeArch","arch","version","deno","platform","browserInfo","navigator","browserPatterns","pattern","match","exec","userAgent","browser","getBrowserInfo","_platformHeaders","makeReadableStream","args","ReadableStream","ReadableStreamFrom","iterable","iter","Symbol","asyncIterator","iterator","start","pull","controller","done","next","close","enqueue","cancel","return","ReadableStreamToAsyncIterable","stream","reader","getReader","result","read","releaseLock","e","cancelPromise","FallbackEncoder","body","bodyHeaders","encodeUTF8_","decodeUTF8_","encodeUTF8","str","encoder","TextEncoder","encode","decodeUTF8","bytes","decoder","TextDecoder","decode","_LineDecoder_buffer","_LineDecoder_carriageReturnIndex","_APIPromise_client","_AbstractPage_client","LineDecoder","chunk","binaryChunk","ArrayBuffer","buffers","length","buffer","output","index","concatBytes","lines","patternIndex","findNewlineIndex","carriage","push","subarray","endIndex","preceding","line","flush","startIndex","i","findDoubleNewlineIndex","NEWLINE_CHARS","Set","NEWLINE_REGEXP","Stream","fromSSEResponse","response","consumed","async","sse","abort","product","sseDecoder","SSEDecoder","lineDecoder","sseChunk","data","newData","slice","iterSSEChunks","_iterSSEMessages","event","console","raw","fromReadableStream","readableStream","iterLines","tee","left","right","teeIterator","queue","shift","toReadableStream","self","ctrl","chunks","endsWith","substring","join","startsWith","fieldname","_","indexOf","delimiter","partition","defaultParseResponse","props","requestLogID","startTime","url","__streamClass","__binaryResponse","contentType","mediaType","split","trim","addRequestID","json","durationMs","Date","now","Array","isArray","defineProperty","enumerable","APIPromise","Promise","responsePromise","parseResponse","resolve","_thenUnwrap","transform","asResponse","then","p","withResponse","all","request_id","parsedPromise","onfulfilled","onrejected","catch","onfinally","finally","AbstractPage","hasNextPage","getPaginatedItems","nextPageRequestOptions","getNextPage","nextOptions","requestAPIList","iterPages","page","item","PagePromise","request","Page","has_more","first_id","last_id","query","before_id","cursor","after_id","checkFileSupport","File","isOldNode","versions","node","parseInt","makeFile","fileBits","fileName","getName","filename","path","pop","isAsyncIterable","supportsFormDataMap","createForm","fetch","fetchObject","cached","promise","FetchResponse","Response","FormData","supportsFormData","form","addFormValue","append","type","blob","Blob","isNamedBlob","entry","prop","isBlobLike","size","arrayBuffer","isFileLike","lastModified","isResponseLike","toFile","URL","pathname","getBytes","parts","find","part","isView","getOwnPropertyNames","propsForError","APIResource","_client","brand_privateNullableHeaders","for","iterateHeaders","values","nulls","shouldClear","row","didClear","buildHeaders","newHeaders","targetHeaders","nullHeaders","seenHeaders","lowerName","delete","add","encodeURIPath","encodeURIComponent","pathEncoder","statics","params","postPath","reduce","previousValue","currentValue","test","pathOnly","invalidSegments","invalidSegmentPattern","lastEnd","underline","acc","segment","spaces","repeat","arrows","createPathTagFunction","Files","list","betas","getAPIList","fileID","download","Accept","retrieveMetadata","upload","post","opts","multipartFormRequestOptions","Models","retrieve","modelID","JSONLDecoder","fromResponse","Batches","create","messageBatchID","results","batch","results_url","processing_status","id","strip","tokens","lastToken","lastCharacterOfLastToken","tokenBeforeTheLastToken","partialParse","input","token","tail","splice","lastIndexOf","reverse","unstrip","current","char","danglingQuote","NUMBERS","LETTERS","tokenize","_BetaMessageStream_instances","_BetaMessageStream_currentMessageSnapshot","_BetaMessageStream_connectedPromise","_BetaMessageStream_resolveConnectedPromise","_BetaMessageStream_rejectConnectedPromise","_BetaMessageStream_endPromise","_BetaMessageStream_resolveEndPromise","_BetaMessageStream_rejectEndPromise","_BetaMessageStream_listeners","_BetaMessageStream_ended","_BetaMessageStream_errored","_BetaMessageStream_aborted","_BetaMessageStream_catchingPromiseCreated","_BetaMessageStream_response","_BetaMessageStream_request_id","_BetaMessageStream_getFinalMessage","_BetaMessageStream_getFinalText","_BetaMessageStream_handleError","_BetaMessageStream_beginRequest","_BetaMessageStream_addStreamEvent","_BetaMessageStream_endRequest","_BetaMessageStream_accumulateMessage","JSON_BUF_PROPERTY","tracksToolInput","content","BetaMessageStream","messages","receivedMessages","AbortController","_emit","anthropicError","reject","runner","_run","_fromReadableStream","createMessage","_addMessageParam","_createMessage","executor","_emitFinal","_addMessage","emit","signal","aborted","addEventListener","_connected","ended","errored","on","listener","listeners","findIndex","l","once","emitted","currentMessage","finalMessage","finalText","filter","forEach","at","WeakSet","textBlocks","block","messageSnapshot","delta","citation","citations","partial_json","thinking","signature","snapshot","container","stop_reason","stop_sequence","usage","output_tokens","input_tokens","cache_creation_input_tokens","cache_read_input_tokens","server_tool_use","content_block","snapshotContent","jsonBuf","writable","pushQueue","readQueue","MODEL_NONSTREAMING_TOKENS","DEPRECATED_MODELS","Messages","arguments","batches","model","timeout","_options","maxNonstreamingTokens","calculateNonstreamingTimeout","max_tokens","countTokens","Beta","models","files","Completions","_MessageStream_instances","_MessageStream_currentMessageSnapshot","_MessageStream_connectedPromise","_MessageStream_resolveConnectedPromise","_MessageStream_rejectConnectedPromise","_MessageStream_endPromise","_MessageStream_resolveEndPromise","_MessageStream_rejectEndPromise","_MessageStream_listeners","_MessageStream_ended","_MessageStream_errored","_MessageStream_aborted","_MessageStream_catchingPromiseCreated","_MessageStream_response","_MessageStream_request_id","_MessageStream_getFinalMessage","_MessageStream_getFinalText","_MessageStream_handleError","_MessageStream_beginRequest","_MessageStream_addStreamEvent","_MessageStream_endRequest","_MessageStream_accumulateMessage","MessageStream","readEnv","env","_a","_BaseAnthropic_encoder","BaseAnthropic","baseURL","apiKey","authToken","dangerouslyAllowBrowser","window","document","Anthropic","DEFAULT_TIMEOUT","defaultLogLevel","fetchOptions","maxRetries","withOptions","defaultQuery","validateHeaders","authHeaders","apiKeyAuth","bearerAuth","Authorization","stringifyQuery","getUserAgent","defaultIdempotencyKey","makeStatusError","buildURL","isAbsoluteURL","_k","isEmptyObj","search","_calculateNonstreamingTimeout","maxTokens","defaultTimeout","prepareOptions","prepareRequest","methodRequest","patch","put","method","remainingRetries","makeRequest","optionsInput","retriesRemaining","req","buildRequest","retryCount","padStart","retryLogStr","fetchWithTimeout","headersTime","retryMessage","isTimeout","retryRequest","responseInfo","ok","shouldRetry","errText","errJSON","errMessage","init","ms","setTimeout","isReadableBody","duplex","toUpperCase","clearTimeout","shouldRetryHeader","responseHeaders","timeoutMillis","retryAfterMillisHeader","timeoutMs","parseFloat","Number","isNaN","retryAfterHeader","timeoutSeconds","calculateDefaultRetryTimeoutMillis","numRetries","min","pow","defaultTime","inputOptions","n","isInteger","validatePositiveInteger","buildBody","idempotencyHeaders","idempotencyHeader","idempotencyKey","trunc","defaultHeaders","rawHeaders","DataView","URLSearchParams","HUMAN_PROMPT","AI_PROMPT","AnthropicError","completions","beta"],"sourceRoot":""}